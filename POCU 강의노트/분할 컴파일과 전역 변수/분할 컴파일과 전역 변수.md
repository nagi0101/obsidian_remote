---
Created: 2023-12-23T18:24:00
Updated: 2023-12-24T23:34:00
Course: COMP2200
tags:
  - Grammar
  - Computer_System
Reviewed: false
---
- [[#여러개의 파일과 C 빌드|여러개의 파일과 C 빌드]]
- [[#extern 키워드|extern 키워드]]
	- [[#extern 키워드#사용법|사용법]]
	- [[#extern 키워드#함수는?|함수는?]]
- [[#전역변수의 문제|전역변수의 문제]]
	- [[#전역변수의 문제#static 키워드|static 키워드]]
- [[#중간정리|중간정리]]
- [[#순환 헤더 인클루드|순환 헤더 인클루드]]
	- [[#순환 헤더 인클루드#해결법1|해결법1]]
	- [[#순환 헤더 인클루드#해결법2: 인클루드 가드|해결법2: 인클루드 가드]]


## 여러개의 파일과 C 빌드
---
1. 두 개 이상의 .c 파일을 개별적으로 컴파일하여 오브젝트 파일을 만듦
	1. 이들은 멀티스레딩으로 동시에 진행 가능하기도 함. 어찌 되었건 각자가 독립적으로 컴파일 되는 것이 중요.
2. 오프젝트 파일을 서로 링크하여 실행파일 만듦
	1. 이들은 동시 진행 어려움.

```C
/* monster_repo.h */ 
void add_monster(void);

/* monster_repo.c */
#include "monster_repo.h"

int g_mob_count = 0;

void add_monster(void)
{
	++g_mob_count;
}

/* main.c */
#include <stdio.h>
#include "monster_repo.h"

int main(void)
{
	add_monster();
	printf("# monsters: %d\n", g_mob_count);

	return 0;
}
```
![[Pasted image 20231223190654.png]]
- C 파일의 컴파일은 독립적으로 진행되기 때문에 main.c는 g_mob_count의 존재를 모름.
- 그렇다고 main에서 g_mob_count를 또 추가하면 컴파일은 되지만 링커가 오류를 밷음.
	- ![[Pasted image 20231223191036.png]]
	- 같은 이름의 전역 변수가 두 개면 안 됨. 링커가 구분을 못 함.
- 따라서 함수 전방선언과 같이 구멍을 비워두라는 표시가 필요.

## extern 키워드
---
- external의 약자. 외부의 것을 가져다 쓸테니 구멍으로 비워두라는 키워드임.
```C
/* monster_repo.h */ 
extern int g_mob_count;
void add_monster(void);

/* monster_repo.c */
#include "monster_repo.h"

int g_mob_count = 0;

void add_monster(void)
{
	++g_mob_count;
}

/* main.c */
#include <stdio.h>
#include "monster_repo.h"

int main(void)
{
	add_monster();
	printf("# monsters: %d\n", g_mob_count);

	return 0;
}

```
- 혹은 main함수에 작성하기도 함. 공개하기 싫은 전역 변수는 헤더에 포함시키지 않기도 함.
- 접근 제어와는 느낌이 다른 것이 이쪽은 사용하는 쪽에서 그냥 가져다 쓰겠다고 선언하는 것.

### 사용법
- 그럼 extern을 사용하려면 .c를 일일이 열어서 전역 변수를 찾아야 하는가?
	- 그래도 되지만 라이브러리를 가져다 쓸 경우 .c를 볼 수 없음. 이 경우 제작자가 extern을 헤더에 포함시켜줌. 그게 아닐 경우 바이너리 뜯지 않는 이상 못 쓴다고 생각하면 됨.
- 여전히 c 안에 직접 extern을 넣는 경우도 많음
	- 헤더에 두면 누구라도 쓸 수 있게 해주는 것
	- c에 넣는 것은 파일 내에서만 쓰려고 하는 것
- 참고로 이 경우에도 링커 오류.
	- 헤더는 복붙되니 결과적으로 전역변수를 두 번 선언한 것과 같게 된다.
```C
/* monster_repo.h */ 
int g_mob_count = 0;
void add_monster(void);

```
### 함수는?
- 함수 앞에 extern 붙일 수 있음. 근데 그냥 기본값이 extern.
- 굳이 없어도 {} 없으면 프로토타입 선언인 것 쉽게 알 수 있음. 보통 안 쓴다.
- 호출 전에 직접 원형을 넣거나 헤더에 넣을 수 있음. 보통 헤더에 넣는다.

## 전역변수의 문제
---
- 확실히 문제는 있음
	- extern 사용하면 아무나 내 파일 안의 변수를 확인, 수정 가능
	- 파일이 몇만개 있으면 그 중 누가 변수를 바꾸는지 모름.
- 다른 놈들이 내 전역변수를 못 쓰게 하려면, 즉 내 파일 안에서만 쓰려면 전역 변수를 만들 때 static 키워드를 붙이면 됨.
```C
/* monster_repo.h */ 
void add_monster(void);

/* monster_repo.c */
#include "monster_repo.h"

static int s_mob_count = 0;

void add_monster(void)
{
	++s_mob_count;
}

/* main.c */
#include <stdio.h>
#include "monster_repo.h"

extern int s_mob_count;

int main(void)
{
	add_monster();
	printf("# monsters: %d\n", s_mob_count);

	return 0;
}

```
![[Pasted image 20231223193408.png]]
- 그렇게 하면 컴파일은 되는데 링크가 안 됨.
- static으로 선언된 전역변수는 링커의 고려 대상이 아님. 레이블조차 안 남아 있을 수도 있음.
### static 키워드
- 다른 파일에서 전역 변수에 접근 못 하도록 막는 법
- 변수의 범위를 파일로 한정
- 흔히 정적 변수라고 함
- 여전히 전역변수로 프로그램 실행동안 메모리에 존재하기는 함. 다만 파일 외부에서 접근 불가.
- 지역 변수에도 static을 넣을 수 있음. 
```C
/* monster_repo.c */
#include "monster_repo.h"

void add_monster(void)
{
    static int s_mob_count = 0;
    ++s_mob_count;
}
```
- 이 경우 static이 개념상 전역변수. 허나 함수에서만 접근 가능함. 함수가 반환되어도 여전히 값이 저장되어 있음. 함수가 처음 실행될 때만 초기화되며 이후 실행시에는 초기화하지 않음.
	- 앞에서 봤던 static과는 조금 다른 개념.
- 함수 역시 앞에 static 키워드를 넣으면 외부로부터 접근을 막을 수 있다.

## 중간정리
---
1. 헤더 파일에는 선언만 들어간다
	- 함수 선언
	- 전역 변수 extern 선언
1. .c에는 정의가 들어간다
	- 함수 정의
	- 전역 및 정적 변수 정의

## 순환 헤더 인클루드
---
- 헤더 a, b, c가 순환적으로 서로 include 하는 경우 발생
- 컴파일러가 반복해서 include를 복붙하다가 최대 한계를 넘어가 컴파일 에러 발생
### 해결법1
- include는 .c에서만 하기
- include 대신 전방선언 하기
- 그러나 어쩔수 없이 서로 include 해야할 일이 있다.
	- 이 경우 인클루드 가드 사용

### 해결법2: 인클루드 가드
- C에서 헤더가 여러번 include되는 것을 막는 업계 표준
```C
/* foo.h */
#ifndef FOO_H
#define FOO_H
/* 헤더 파일 내용 */
#endif /* FOO_H */
```
- 전처리기 지시문을 사용
- 어떤 상수를 정의하고, 전처리기에게 조건적으로 include하라고 지시.
- 중복되어 include가 될 경우 FOO_H가 정의되어 있기 때문에 내용이 복사되지 않고, 순환 헤더 인클루드가 해결됨.
- ==코딩 표준: 인클루드 가드는 언제나 사용하자.==
	- 해결법 1과 2 모두 쓸 수 있지만, 2는 언제나 사용하자. C에서 제공하는 라이브러리도 이미 이것을 다 사용함.
-  pragma once도 있음. 조금 더 간단하지만 C 표준은 아님. 
	- 컴파일러들이 다들 인클루드 가드 하는 것 아니까 쉽게 하라고 줄여둔 것.
	- 포팅이나 호환 생각하면 인클루드 가드 쓰는 것이 맞음.  
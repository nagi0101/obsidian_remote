---
Created: 2023-12-18T14:22:00
Updated: 2023-12-18T14:22:00
Course: COMP2200
Tags:
  - Computer_System
Reviewed: false
---
- [[#스택 메모리|스택 메모리]]
- [[#스택 메모리 구조|스택 메모리 구조]]
- [[#어셈블리|어셈블리]]
	- [[#어셈블리#배열을 넣으면?|배열을 넣으면?]]
- [[#스택의 크기|스택의 크기]]
- [[#스택 오버플로|스택 오버플로]]
	- [[#스택 오버플로#너무 큰 데이터 할당|너무 큰 데이터 할당]]
	- [[#스택 오버플로#재귀함수|재귀함수]]

## 스택 메모리
---

- 자료구조인 스택이랑 햇갈리지 말것.
    - 작동 방법(LIFO)이 동일해서 스택이란 이름을 쓸 뿐
    - 메모리는 주소 오름차순으로 간략화해서 코드-데이터-힙-스택 순으로 구성됨.
    - 스택은 메모리 주소가 높은 곳에서 낮은 곳으로 쌓임.
- 각 함수에서 사용하는 지역변수 등을 임시적으로 저장하는 공간
- 스택 매모리 크기는 프로그램 빌드시(컴파일 타임에) 결정됨
- 스택 메모리 위치(주소)는 실행 시 결정됨
    - 운영체제가 알아서 넣어줌.
    - 가상 페이징 등으로 인해 코드-데이터-힙-스택 순으로 항상 구성되지는 않을 수 있음.
    - 실행시마다 주소값이 달라질 수 있음.
- 기본 자료형 변수는 스택 메모리를 차지한다.
    - 여태까지 모든 기본 자료형 변수를 new 없이 사용한 것은 스택 메모리에 할당되었기 때문
    - 기본 자료형을 함수 매개변수로 전당하면 스택에 복사본을 만듫 → 이게 값형
    - 스택 메모리를 빌리고 반환할 때마다 언제나 빈 공간 없이 차곡차곡 쌓여 있음
    - new로 만든 데이터는 힙(heap) 메모리에 할당됨.
        - 이 경우 메모리에 구멍이 뚫릴 수 있음(단편화)
        - 이것 때문에 할당을 요청할 때마다 운영체제가 힙에 연속된 길이의 메모리를 찾느라 느림.
        - 힙보다 스택을 사용하는 것이 대부분의 경우 빠름.

## 스택 메모리 구조
---
- ESP(Extended Stack Pointer): 현재 스택 포인터
- EBP(Extended Base Pointer): 현재 스택 프레임 첫 주소
- EBP에서 ESP까지가 현재 사용중인 스택 메모리.
    - EBP, ESP는 스택 활용을 위한 CPU 레지스터.

## 어셈블리
---

```C
int add(const int a, const int b)
{
	int res = a + b;
	return res;
}

int main(void)
{
	int a = 1;
	int b = 2;
	return add(a, b);
}
```
![[Pasted image 20231224112634.png]]
1. main 함수가 실행되면 EBP push 후 EBP에 ESP 대입. 그 후 ESP를 실행에 필요한 메모리만큼 빼서 내림.
	1. 실행에 필요한 메모리는 보통 지역 변수 저장을 위한 메모리.
	2. 추가로 경우에 따라 이후 다른 함수 실행을 위해 argument들을 복사하기 위한 메모리를 미리 잡기도 함.
2. a가 점유하는 메모리에 1 저장.
	1. a가 점유하는 메모리는 \[EBP - 8]등 EBP로부터의 상대적 거리로 계산.
3. 위와 같은 방식으로 b가 점유하는 메모리에 2 저장.
4. add 함수의 인자로 넘기는 값들을 eax, ecx등의 레지스터에 저장.
5. ESP+4, ESP+8등 ESP에 대한 상대적 위치로 레지스터의 값들 저장. 지금은 초기에 함수 실행에 필요한 인자를 복사하기 위한 메모리까지 미리 포함하여 ESP의 값을 내려두었기 때문에 바로 복사함.
6. call \[add 함수의 주솟값]으로 함수 실행을 시작함. 이 때 ESP가 가리키는 메모리에 함수 return 후 다음에 실행할 명령어 주소 저장해둠. 그 후 ESP는 1 증가하여 다음 메모리 가리킴.
7. add 함수 실행시 먼저 EBP push 후 EBP에 ESP 대입. 그 후 ESP를 함수 실행에 필요한 메모리만큼 빼서 내림. (main 함수 첫 실행과 같음)
8. 연산 수행 후 결과값을 eax 레지스터에 저장.
9. ESP를 add 함수 실행시 뺐던 만큼 더해서 EBP와 ESP를 같게 만듬. 스택 프래임 반환.
10. pop EBP하여 EBP를 main 함수의 EBP로 복원.
11. ret 명령 호출. add 함수 실행 전 1 증가시켰던 ESP 1 감소시키고 ESP가 가리키는 자리에 위치한 주소값에 위치한 명령어로 return.
12. add의 경우와 같이 main 함수의 스택 포인터 복구. add의 반환값을 그대로 반환하기 때문에 반환값에 대한 추가적인 처리 없이 바로 반환. ret 명령 실행되어 main 함수 종료. 

### 배열을 넣으면?
---
- char\[64] 할당하고 어셈블리 뜯어봄.
    - 0x54 - 0xC = 0x48 = 72. 72바이트 더 할당됨.
- 이렇게 스택을 사용하면 동적 할당하는것보다 훨씬 빠름
    - 그냥 정해진 메모리에서 위아래로 왔다갔다 하면 되고
    - 메모리 달라고 OS에 요청을 보낼 필요도 없음.

## 스택의 크기
---
- 스택 크기는 한정적임.
    - 타깃 플랫폼 따라 달라짐.
- 프로그래머가 컴파일 시 스택의 크기를 정해줄 수도 있음.
- clang windows에서 아무것도 안 정해주면 대략 1MB 정도
- 멀티스레딩의 경우
    - 스레드마다 스택이 따로 할당됨.
    - 운영체제가 스레드가 생성될 때 새로운 스택을 같이 할당해줌
    - 스레드마다 콜 스택이 따로 있다.
        - 즉, 어떤 스레드가 다른 스레드의 함수로 가서 작업하는 등의 일은 불가능하다.

## 스택 오버플로
---
### 너무 큰 데이터 할당

![[Untitled 2 8.png|Untitled 2 8.png]]

- 스택의 크기가 약 1MB일 때 위와 같은 코드를 실행하면 곧바로 스택 오버플로 발생.
- 근데 어떤 경우에는 아무 문제 없이 돌기도 함.
    - 도구에 따라 실행 도중에 문제가 안 보일 수도 있음.
    - 이런 경우는 더 문제. 나중에 다른 컴퓨터에서 돌렸는데 이것 저것 크래쉬 날 수도 있음.
- 너무 큰 데이터는 스택에 넣으면 안 된다.
    - 이럴 경우 사용하는 것이 동적 메모리 할당.

### 재귀함수
- 위와 같은 이유로 재귀함수를 너무 깊게 호출하면 스택 오버플로 발생.
- 위와 같이 꽥이 날 수도 있고, 운영체제가 잡아줄 수도 있고, 도구가 잡아줄 수도 있고, 아무 소리 없이 넘어갈 수도 있음.
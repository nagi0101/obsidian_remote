---
Created: 2023-12-23T18:08:00
Updated: 2023-12-23T18:26:00
Course: COMP2200
tags:
  - Computer_System
Reviewed: false
---
- [[#C 프로그램의 빌드 과정|C 프로그램의 빌드 과정]]
- [[#.c와 .h 파일|.c와 .h 파일]]
	- [[#.c와 .h 파일#헤더 파일이 필요한 이유|헤더 파일이 필요한 이유]]
	- [[#.c와 .h 파일#함수 선언만 가지고 어떻게 프로그램이 돌 수 있지?|함수 선언만 가지고 어떻게 프로그램이 돌 수 있지?]]
	- [[#.c와 .h 파일#\#include <> vs \#include “”|\#include <> vs \#include “”]]
- [[#전처리|전처리]]
- [[#컴파일|컴파일]]
- [[#어셈블|어셈블]]
- [[#링크|링크]]
	- [[#링크#링크 단계가 분리되어 있는 이유|링크 단계가 분리되어 있는 이유]]
- [[#라이브러리|라이브러리]]
	- [[#라이브러리#정적 라이브러리|정적 라이브러리]]
	- [[#라이브러리#동적 라이브러리|동적 라이브러리]]



- C의 컴파일 모델은 다른 언어에서도 많이 참고해서 가져감.
- 물론 시간이 많이 지난 모델이기에 각 언어의 빌드 과정마다 진보되는 부분이 있음. 그러나 기본적인 골자는 비슷하다.

## C 프로그램의 빌드 과정
---
- 빌드?
    - 소스코드를 기계어 명령어로 변환하는 과정
    - 그리고 그 명령어를 모아 기계에서 실행 가능한 실행파일로 만드는 과정
- C빌드는 4 단계로 나눠진다.
    - 전처리(preprocessing)
    - 컴파일(compilation)
    - 어셈블(assembling)
    - 링크(linking)
- 전처리-컴파일-어셈블을 합쳐서 컴파일이라고도 부른다. 그럼 컴파일-링크의 2단계.
- 컴파일-어셈블을 합쳐서 컴파일이라고도 부른다. 그럼 전처리-컴파일-링크의 3단계.

## .c와 .h 파일
---

```C
/* adder.h */
int add(const int a, const int b);

/* adder.c */
\#include "adder.h"

int add(const int a, const int b)
{
	return a + b;
}

/* main.c */
\#include "adder.h"

int main(void)
{
	const int res = add(1, 2);
	return 0;
}
```

- 두 종류의 소스코드 파일이 있음: .h와 .c

**C 파일**

- 실제 프로그램을 돌게 하는 로직 코드를 저장해두는 파일
- 내용물
    - 함수 정의
    - 전역 변수 등
    - 매크로

**헤더 파일**

- 여러 소스코드 파일에 공통적으로 필요한 것들을 저장해두는 파일
- 내용물
    - 함수 선언
    - 매크로
    - extern 변수 선언 등
- \#include로 포함함
- main.c를 컴파일 하려면 add()의 함수 원형을 알아야만 함.
- 이 떄 add.h에 add()의 원형을 저장해두면 main.c가 include를 통해 원형을 알 수 있음.

### 헤더 파일이 필요한 이유
- 없어도 돌릴수는 있지만 코드 구조를 잡고 관리하려면 쓰게 됨.
- 사실 모든 소스코드를 .c 하나에 집어넣을 수도 있지만 100만줄이 넘는 main.c를 보게 될것.
- 연관된 기능끼리 모아서 .c 파일을 분리하게 된다.
- 이 때 동일한 함수를 여러 곳에 써야한다면?
    - 코드 중복은 프로그래머의 대죄다.
    - 유지보수 불가능.
- 여기서 헤더파일 등장. 함수 선언을 여러 C 파일과 공유 가능.
- 요즘 언어에서는 이 과정을 언어 차원에서 자동으로 지원하지만, C는 오래된 언어라서 수동으로 해줘야 함.

### 함수 선언만 가지고 어떻게 프로그램이 돌 수 있지?
- 컴파일 단계를 보면 알 수 있음
- 빌드가 여러 단계로 쪼개져 있는 이유가 정의 없이 선언만 가지고 컴파일이 되게 하기 위해서임.
- 실제 올바른 기능 호출은 링크 단계가 책임짐.
- 자세한건 뒤에서.

### \#include <> vs \#include “”

- 둘의 차이는 디스크 상의 어디에서 헤더 파일을 찾느냐의 차이
- \#include <>
    - <>는 시스템 경로에서만 헤더 파일을 검색.
    - 컴파일러가 제공하는 시스템 헤더 파일을 인클루드 할 때 사용.
- \#include “”
    - “”는 현재 작업중인 디렉터리에서 헤더 파일을 먼저 검색한 뒤 없으면 시스템 경로를 검색
    - 개발자가 구현한 헤더 파일들을 인클루드 할 때 사용.

## 전처리
---
- 소스코드를 입력으로 받아, 트랜슬레이션 유닛을 출력.
- 전처리기(preprocessor)라는 별도의 프로그램이 담당.
- \#으로 시작하는 명령어들은 전처리기 명령어. 이 명령어들은 대부분 복붙하는 방식으로 작동함.
- 입력: C파일 하나
- 처리 과정
    1. 주석 제거
    2. 매크로 확장(복붙)
    3. 인클루드 파일 확장(복붙)
        1. 참고로 헤더파일이 아닌 다른 파일(.c 등)도 include 할 수 있음. 넥슨에서 컴파일 속도 향상을 위해 사용한 [유니티 빌드](https://www.slideshare.net/devcatpublications/ndc2010-unity-build) 기법이 예시.
        2. 그러나 지금 단계에서는 .c를 인클루드 하는 것은 .c와 .h를 구분하지 못하게 하는 독임.
        3. 시스템 헤더 파일을 include 하는 과정도 같다. 그런데 stdio.h가 약 2473줄...
- 출력: 확장된 소스코드(컴파일의 기본 단위인 translation unit)
- 보는 법
    - clang 컴파일 중에 -E 플래그를 넣으면 됨.
        
        ```PowerShell
        clang -std=c89 -W -Wall -pedantic-errors -E adder.c
        ```
        
        ![[Untitled 3 5.png|Untitled 3 5.png]]
        
    - 이게 트랜슬레이션 유닛.
    - 파일로 출력하려면 출력 리디렉션을 쓰면 됨. 화면에 나오는걸 파일에 저장하는 기능.
        
        ```PowerShell
        clang -std=c89 -W -Wall -pedantic-errors -E adder.c > adder.pre
        ```
        
        ![[Untitled 4 4.png|Untitled 4 4.png]]
        

## 컴파일
---
- 컴파일러라는 프로그램이 담당.
- 입력: 트랜슬레이션 유닛
- 출럭: 어셈블리어 코드
    - 어셈블리어는 기계 코드와 거의 1:1로 대응
    - 그러나 여전히 텍스트 파일이어서 사람이 읽기 쉬운 언어. 그래도 이정도면 저수준 언어임.
    - 어셈블리어 코드는 아직 정의를 모르는 심볼을 사용할 수 있음.
        - 심볼: 함수나 변수의 이름 등
        - 이것이 바로 헤더를 통한 선언만으로도 컴파일이 가능한 이유.
    - 컴파일러가 어떤 함수나 변수의 정의를 못 찾을 경우 그 함수의 변수의 주소는 나중에 누군가 채워 넣을것이라는 가정으로 일단 구멍으로 남겨둠.
    - 그 구멍을 메꾸는 것은 링크 단계에서 해줌.
- 보는 법
    
    ```PowerShell
    clang -std=c89 -W -Wall -pedantic-errors -S adder.c
    ```
    
    - -S 플래그를 쓰면 어셈블리어 코드가 .s 파일로 저장됨.
        
        ![[Untitled 5 2.png|Untitled 5 2.png]]
        
    - add: 레이블이 add 함수가 있는 곳.
    - main.c의 어셈블리
        
        ![[Untitled 6 2.png|Untitled 6 2.png]]
        
        - 확인해보면 실재로 callq add를 통해 add 함수를 호출. 주소값은 보이지 않음.
- 어셈블리 코드가 나왔다는 의미는?
    - 이 단계 이후부터 코드는 특정 플랫폼에서만 동작한다는 의미.
    - C가 크로스 플랫폼이란 주장은 컴파일 되기 전까지임.
    - 또한 타겟 플랫폼이 몇 비트냐에 따라 C의 자료형 그기가 달라질 수 있다는 것.
        - 어셈블리에서는 이미 그 자료형 크기가 결정된 후.
    - 참고로 이 과목에선 x86(32비트) 플랫폼 사용.
        - 예는 주로 윈도우 10 운영체제.

  

## 어셈블
---
- 어셈블러가 담당.
- 입력: 어셈블리 코드
- 출력: 오브젝트 코드
    - 기계가 곧바로 이해 가능한 machine code
    - 기계어라고도 한다.
    - 즉, 이진 코드.
    - 어셈블리어 코드와 마찬가지로 여전히 메꿔야 하는 구멍이 있음.
- 보는 법
    
    ```PowerShell
    clang -std=c89 -W -Wall -pedantic-errors -c main.c
    ```
    
    - -c 플래그를 넣어 컴파일하면 .o 파일로 저장됨
    - 바이너리 파일이라 텍스트 편집기에서 보면 제대로 보이지 않음.
    - hex 편집기로 봐야함.
    - main.o에는 나중에 구멍 메꾸기 위해 바이너리에 \_add 레이블이 존재하는 것을 볼 수 있음.        
    - adder.o에는 add()함수의 위치를 표시하기 위해 \_add 레이블 존재함

## 링크
---
- 링커가 담당.
- 입력: 모든 오브젝트 코드들
- 모든 오브젝트 코드들을 모아다 구멍을 메꾼 뒤 실행파일로 저장.
- 처리 과정
    1. 아까 본 어셈블리 코드의 레이블을 참고.
    2. 오브젝트 파일들을 다 모아서 하나의 이진 파일로 만들어주며 add 함수의 위치를 기억.
    3. 이후 함수를 호출하는 코드를 만나면 실행 위치에 아까 그 위치(주소)로 점프하는 코드를 넣어줌.
    4. 선언만 믿고 사용한 함수나 변수가 여전히 구멍으로 남아있다면?(다른 오브젝트 코드에서 정의를 못 찾은 경우)
        
        ![[Untitled 10 2.png|Untitled 10 2.png]]
        
        1. 링커 오류를 밷는다.
        2. 그 함수나 변수가 없어 실행할 방법이 없기에 경고가 아니라 오류.
- 출력: 머신코드 실행파일(.exe, .out)
- 프로그래밍 하다가 링커 오류가 나는 경우: 선언한 함수 원형과 같은 함수 정의를 하지 않은 것임. 이름이 틀렸거나, .c 파일을 같이 컴파일 하지 않았거나…

### 링크 단계가 분리되어 있는 이유

- 수많은 구멍을 컴파일 할때마다 메꾸면 복잡한 문제들이 생김
- .c파일이 많이 있으면 구멍 메꿔주는 일이 매우 복잡해짐.
    - 파일이 수천개나 있는 프로젝트에서 .c 파일 하나 컴파일 할 때마다 모든 함수를 찾아서 구멍을 메꿔줘야 하나?
- 여러 개의 .c 파일에서 동일한 외부 함수를 사용할 경우 최종 실행파일에 그 함수 정의가 중복으로 들어가는 것도 막아야 한다.
    - 이 중복을 어떻게 체크하지?
- 모든 c파일을 한 번에 합쳐서 컴파일하면?
    - 그럼 .c 하나만 수정해도 모든걸 다 컴파일 해야함…
- 결과적으로 .c 하나씩 컴파일해서 오브젝트 파일로 저장해두는 방법이 낫다.
    - 나중에 바뀐 .c 파일만 컴파일해서 새로운 오브젝트 파일 생성
    - 기존에 있던 오브젝트 파일들과 합쳐서 링크
    - 훨씬 빠르다!
    - 그리고 분리시켜 놓으면 정리도 편해짐.
- .o 파일 따로 저장하기
    - main.o, adder.o, \*.0와 같이 오브젝트 파일 명시.     
    - 업계에서도 이렇게 함.

## 라이브러리
---
- 함수 등을 기계어로 변환 후 파일 하나로 저장해둔 것
- 나중에 다른 .c에서 기능이 필요할 때 링크해서 쓸 수 있음
- 두 종류가 존재
	- 정적 라이브러리
	- 동적 라이브러리

### 정적 라이브러리
- 라이브러리 안에 있는 기계어를 최종 실행파일에 가져다가 복사
- 동적 링킹에 비해
	- 실행 파일 크기 큼
	- 메모리 더 잡아먹을 수 있음
	- 실행 속도 빠름
		- 컴파일러와 링커가 최대한 최적화 진행

### 동적 라이브러리
- 실행 파일에 여전히 구멍을 남겨둠
- 런타임에 실재 링킹 일어남
	- 링킹은 운영체제가 해줌. 동적 라이브러리를 로딩하여 런타임에 함수를 찾아 구멍을 매꾸어줌.
- .dll 파일이 이것. (Dynamic link library의 약자)
- 정적 링킹에 비해
	- 실행파일 크기가 작고
	- 여러 실행파일이 동일한 라이브러리 공유 가능
		- 메모리 절약
	- 단점: 동적 라이브러리에는 버전이 있는데, 실행 파일들이 이름은 같지만 버전이 다른 동적 라이브러리를 사용하면 DLL Hell을 맛볼 수 있음.
		- A와 B 은행의 보안 프로그램이 같은 이름의 버전이 다른 DLL을 사용하면 하나를 깔 때마다 다른 하나가 깨짐.
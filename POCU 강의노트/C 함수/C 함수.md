---
Created: 2023-12-18T13:42:00
Updated: 2023-12-18T13:42:00
Course: COMP2200
Tags:
  - Best_Practice
  - Grammar
Reviewed: false
---
- [[#함수|함수]]
- [[#오버로딩|오버로딩]]
- [[#함수 정의의 문제|함수 정의의 문제]]
- [[#함수 선언|함수 선언]]
- [[#매개변수/피연산자 평가 순서|매개변수/피연산자 평가 순서]]
	- [[#매개변수/피연산자 평가 순서#중간 정리|중간 정리]]
	- [[#매개변수/피연산자 평가 순서#연산자 우선순위에 따른 평가 순서|연산자 우선순위에 따른 평가 순서]]
	- [[#매개변수/피연산자 평가 순서#평가 순서를 강제하는 연산자|평가 순서를 강제하는 연산자]]
	- [[#매개변수/피연산자 평가 순서#최종 정리|최종 정리]]


## 함수
---
- 다른 언어의 함수와 크게 다르지 않음
- 접근 제어자 없음
- C 함수는 기본적으로 모두 전역(global) 함수

  

## 오버로딩
---

![[Untitled 13.png|Untitled 13.png]]

- 그런거 없음.
- 따라서 함수 명을 다르게 만들어야 함.

  

## 함수 정의의 문제
---

- C는 언제나 위에서 아래로 코드를 훑음
- C89에서 함수 정의가 등장하기 전에 그 함수를 호출하면 컴파일러가 아래와 같이 가정
    - 반환형은 int
    - 그 매개변수는 아무거나 올 수 있음.
- 따라서, 나중에 컴파일러가 int가 아닌 다른 것을 반환하는 함수를 찾으면 컴파일 오류를 뱉음.

```C
\#include <stdio.h>

int main(void)
{
	foo();
	getchar();
	return 0;
}

void foo(void)   /* 컴파일 에러 */
{
	printf("foo called");
}
```

```C
\#include <stdio.h>

int main(void)
{
	int x = foo();
	getchar();
	return 0;
}

void foo(void)
{
	printf("foo called");
	return 0;
}
```

- 간단한 해결법: 호출 전에 함수의 정의를 위치시키면 문제 없음.
    
    ```C
    \#include <stdio.h>
    
    void foo(void)
    {
    	printf("foo called");
    }
    
    int main(void)
    {
    	foo();
    	getchar();
    	return 0;
    }
    ```
    
- 하지만 함수가 엄청 많아지면?
    - 또 함수들이 함수들을 서로 호출할텐데 정리는?
    - 이럴 때 조금 덜 괴롭게 문제를 해결할 수 있는 방법이 함수 선언.

## 함수 선언
---
- 함수 구현체 없이 함수 원형만 선언해주는 것
- 함수 원형은 다음의 사항들을 명시
    - 함수 이름
    - 반환형
    - 매개변수들의 자료형: 변수 이름은 필수가 아니나 가독성을 위해 넣어주는 것이 좋다.
- 정의는 실제로 함수를 구현해둔것
    - 함수 정의는 그 자체로 함수 선언이기도 함.
- 함수를 사용하기 전에 그 함수를 선언해야한다.
    - 보통은 파일의 제일 위에 선언. 이것을 전방 선언(forward declaration)이라고 함.
    - 혹은 헤더파일에 선언.
- 작동 원리
    - 선언을 통해 컴파일러가 함수의 반환형과 매개변수를 알 수 있음.
    - 나중에 그 함수를 호출할 때 그것을 바탕으로 컴파일.
    - 실제 어디로 가서 함수를 찾아야하는지는 모르기에 주소는 구멍으로 남겨둠.
        - 이 구멍은 링크 단계에서 매워짐.
- 함수가 int를 반환하면 선언 안 해도 되는가?
    - C89에선 맞는 이야기인데…
    - ==코딩 표준: C99부터는 int 가정을 하지 않으니 반드시 함수 선언할것.==
    - 그러나 어떤 컴파일러는 경고만 주고 컴파일은 허용될 수도 있음.
    - 이런 자잘한 것들 때문에 협업할 때 문제 생기느니 모든 함수를 선언하는 것이 좋다.
    - 함수 선언은 반드시, 항상 하는 것이 나와 모두를 위해 좋다.

## 매개변수/피연산자 평가 순서
---

```C
\#include <stdio.h>

int add(int op1, int op2)
{
	printf("add()\n");
	return op1 + op2;
}

int subtract(int op1, int op2)
{
	printf("subtract()\n");
	return op1 - op2;
}

int main(void)
{
	int num1 = 128;
	int num2 = 256;
	/* add()와 subtract() 중 어느 것이 먼저 실행될까? */
	printf("%d, %d\n", add(num1, num2), subtract(num1, num2));

	return 0;
}
```

- 정답: 모름
- 표준에는 함수 매개변수 평가 순서는 명시되어있지 않음(unspecified)
    - undefined와는 다름
    - unspecified: 표준에서 이런 경우가 있을 때 경우의 수를 줌
        - 앞부터 평가하는 방법, 뒤부터 평가하는 방법 두 가지 방법이 있는 것은 명시되어 있으나, 둘 중 어떤 방법을 써야하는지는 안 정해둠.
- 컴파일러마다 달라질 수 있음.
- printf() 전에 add()와 subtract()가 호출되는 것은 보장.
- 그러나 누가 먼저 호출되는지는 컴파일러 마음.
- 아래와 같은 경우를 주의해야 한다.
    
    ```C
    size_t g_boss = 0;
    
    /* 던전을 찾으면 1 반환, 내부에서 g_boss 세팅 */
    int find_next_dungeon(void);
    
    /* g_boss가 1이면 보스몹도 같이 소환, 성공시 1 반환. */
    int spawn_monster(void);
    ```
    
    ```C
    /* 또 다른 함수 내부*/
    if(find_next_dungeon() + spawn_monster() == 2)
    {
    	/* 멋진 코드 */
    }
    ```
    
    - 위처럼 코드 짜면 안 됨.
    - find_next_dungeon()이 먼저 호출된다는 보장이 없음.
        - ‘+’는 sequence point가 아님.
    - 한 줄에 있는 함수 호출 순서에 의존해서 코드를 작성하지 말것.
    - 해법: 두 함수를 두 줄에 따로 호출할 것.
        - ‘;’는 언제나 sequence point. 줄의 끝에 쓰는 그것도, for문 안에 쓰는 그것도 그러함.
- 두 수를 나눈 몫은 무엇일까?
    ```C
    \#include <stdio.h>
    
    float devide(int op1, int op2)
    {
    	printf("%d / %d = ", op1, op2);
    	return op1 / (float)op2;
    }
    
    int main(void)
    {
    	int num = 0;
    	float result = devide(++num, ++num); /* 주의 */
    	
    	printf("%f\n", result);
    	
    	return 0;
    }
    ```
    
    - 결과가 정의되지 않음(undefined behavior)
        - 뭔 일이 일어날지 절대 모름.
	        - unspecified는 컴파일러마다 다른거지 큰일은 안 남. 표준에 지정된 동작을 따라 유추해보면 몇 가지 경우의 수 안에 들어감.
	        - 이 경우는 진짜 모름. 표준이 이 경우를 고려하지 않고 있으며, 추측도 할 수 없음.
        - 심지어 동시에 평가될 수도 있음
	        - 어떤 cpu에서 프로그램을 돌릴지 모르니, 파이프라인을 통해 두 인자를 동시에 평가할 수도 있음. 이런 경우는 한 변수 안에서 비트가 꼬일 수도 있음.
    - 기본적으로 한 줄에서 동일한 변수를 여러 번 바꾸면 위험하다.
        - 함수 매개변수 평가 순서도 컴파일러마다 다를 수 있음
        - 매개변수 뿐만 아니라 +같은 평가 순서를 강제하지 않는 연산자도 위험. =도 마찬가지.
        - 뭐든간에 가독성도 안 좋으니 다 하지 마라.

### 중간 정리

- 한 줄에 있는 함수 호출 순서에 의존해서 코드를 작성하지 말것.
- 한 표현식에서 같은 변수를 여러 번 바꾸지 말것.

### 연산자 우선순위에 따른 평가 순서

```C
/* add, subtract, devide의 평가 순서는? */
int result = add(num1, num2) + subtract(num1, num2) * devide(num1, num2);
```

- 모름(컴파일러 마음)
- 연산자 우선순위와 평가 순서는 하등 상관 없는 이야기임.
- 연산자 우선순위는 평가 결과에 대한 이야기고, 평가 순서에 대한 이야기는 아님.

### 평가 순서를 강제하는 연산자

- 아래의 코드의 실행 결과는?
    
    ```C
    int i = 0;
    int j = 0;
    int k = 0;
    
    if(++i || ++j && ++k)
    {
    	printf("true!\n");
    }
    
    printf("%d, %d, %d\n", i, j, k);
    ```
    
    ![[Untitled 6 3.png|Untitled 6 3.png]]
	 - 연산자 우선순위와 평가 순서는 다름.
	- 연산자 우선순위에 따라 ++j && ++k가 괄호로 묶이는 것은 맞음.
	- 그러나 그것은 값이 나온 뒤 어떤 순서로 AND, OR 하냐의 문제임.
	- 실제 실행은 || 연산자의 왼쪽부터. ++i가 평가된 후 short circuit에 의해 || 뒤에는 실행을 안 함.
	- 괄호로 || 뒤를 묶고 실행해도 결과는 동일.
        
        ![[Untitled 8 3.png|Untitled 8 3.png]]
        
- &&와 ||는 평가를 강제하는 연산자임.
    - 논리 연산자 &&와 ||는 왼쪽 피연산자를 먼저 실행.
    - 왼쪽 피연산자의 평가만으로 오른쪽 피연산자 평가를 안 할 수도 있음.

### 최종 정리
- 한 줄에 있는 피연산자들은 기본적으로 ==평가 순서가 보장 안 된다==고 생각하자!
    - 그것에 기반해 로직을 작성하는 것은 잘못된 습관.
- 그리고 ||와 &&정도만 된다고 암기하자…
    - short circuit은 어짜피 알아야함.
- 삼항 연산자도 평가 순서 보장함.
    - 그냥 if/else 줄여 쓴거임.
- 당연히 ;도 됨
- 당연히 함수를 실제 실행하기 전에 모든 매개변수도 평가됨.
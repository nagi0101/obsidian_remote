---
Created: 2023-12-16T10:03:00
Updated: 2023-12-16T10:03:00
Course: COMP2200
Tags:
  - Best_Practice
  - Grammar
Reviewed: false
---

- [[#C89/ANSI-C|C89/ANSI-C]]
- [[#include <>| \#include <>]]
- [[#stdio.h|stdio.h]]
	- [[#stdio.h#C 표준 라이브러리?|C 표준 라이브러리?]]
	- [[#stdio.h#<stdio.h>의 역할|<stdio.h>의 역할]]
- [[#main(void)|main(void)]]
	- [[#main(void)#return 0;|return 0;]]
	- [[#main(void)#(void)|(void)]]
	- [[#main(void)#main()함수와 커맨드 라인 인자|main()함수와 커맨드 라인 인자]]
- [[#printf()|printf()]]
- [[#주석|주석]]
- [[#C는 절차적 언어|C는 절차적 언어]]


> [!important]  
> 이번 과목에서 사용할 컴파일 옵션. IDE는 사용하지 않음.clang -std=c89 -W -Wall -pedantic-errors main.cC는 임베디드 시스템에 자주 쓰며, 오래된 코드베이스에서 자주 사용함. 이런 환경의 단점은 기계에 최적화된 툴을 사용하기 때문에 사용자가 많지 않아 툴 지원이 좋지 않음. CMD 환경에서 코드를 다루는 일이 비일비재함.디버드 툴 역시 같은 이유로 사용이 어려울 수 있음. 그렇기에 눈으로 코드를 쫒으며 내부 상태를 예측하는 능력을 키워야함. C 자체가 단순하고 동작이 명료하기에 충분히 가능.  

## C89/ANSI-C
---
- ANSI에 의해 채택된 최초의 C 표준. C90이랑은 글자 몇개만 바뀐 수준이라 같은 표준으로 봄.
- 아직 대부분의 컴파일러가 C89를 기준으로 만들어짐.
- 오늘날 대부분의 코드도 이 버전.
    - 많은 임베디드 시스템은 여전히 C89만 지원.
    - 소형 하드웨어는 전용 운영체제만 지원(범용 운영체제 지원 X)
    - 하드웨어 + 운영체제용으로 컴파일 가능하며 하드웨어에 직접 접근할 수 있는 컴파일러를 제작한다면 C89 표준이 가장 간단함.
- 위와 같은 이유로 C89에 중점을 두되 나머지 표준들은 곁다리로 배워두는 것이 가장 알맞음.

## \#include <>
---
- 전처리기 지시문 중 하나.
- <>안에는 실제 디스크에 존재하는 파일 이름. 해당 헤더 파일의 내용을 복사하여 그대로 지시문이 쓰인 자리에 붙여넣는다.
- 컴파일 과정에서 헤더 파일의 함수들도 같이 컴파일하며 포함됨. 자세한 내용은 이후 컴파일/링크 참고.
- 요즘 언어에서는 이런 주먹구구식으로 하지 않음. 당시엔 성능상의 제약사항들이 많았기에 이런 방식으로 구현됨.

**사용법**
```C
#include <stdio.h> /* 컴파일 */
#include 'stdio.h' /* 컴파일 오류 */
#include "stdio.h" /* 컴파일. 그러나 이렇게 사용하지 말것. 이유는 추후 배움. */
```

## stdio.h
---
### C 표준 라이브러리?
- 문자열 처리, 수학 계산, 입출력 처리, 메모리 관리등에 필요한 함수와 자료형들을 모아놓은 것.
- C#의 .NET Core 프레임워크와 동등한 녀석.

### <stdio.h>의 역할
- libc에서 표준 입출력(Standard Input and Output)을 담당.
- 스트림 입출력에 관련된 함수 포함.
- printf(), scanf(), fopen(), fclose() 등  

## main(void)
---
```C
int main(void)
{
	/* 코드 생략 */

	return 0;
}
```

- 프로그램의 진입점(entry point). 실행파일 실행시 main(void) 함수가 자동적으로 실행됨.
- 약속된 이름이기에 바꿀 수 없음.

### return 0;
- 반드시 int를 반환해야함.
    - 0: 프로그램에 문제가 없었다는 뜻.
    - 그 외: 일반적으로는 양수를 반환하여 오류 표현, 그러나 음수를 반환하는 것도 문제는 없음.
- 종료 코드 확인법:
    - 윈도우 CMD: 프로그램 실행 후 %errorlevel% 출력       
    - Shell: 프로그램 실행 후 $? 출력
    - windows powershell: $LASTEXITCODE 출력

### (void)
- void를 생략한다고 꼭 매개변수가 없는 것이 아님. 표준이 좀 모자른 부분.
    - 함수 선언에서 void 생략: 매개변수를 받는다는 뜻. But 매개변수의 갯수과 자료형을 모름.
    - 함수 정의에서 void 생략: 매개변수가 없다는 뜻.
- 따라서 ==언제나 void를 넣는 습관을 기르자.==

### main()함수와 커맨드 라인 인자

```C
int main(int argc, char* argv[])
{
	/* 코드  생략 */
	return 0;
}

// ....또는

int main(int argc, char** argv)
{
	/* 코드  생략 */
	return 0;
}
```

- 위와 같은 형태로 커맨드 라인으로부터 인자를 문자열로 받아올 수 있음.

  

## printf()
---
- 화면에 데이터를 출력할 때 사용.
- Print formatted라는 뜻.
- C#은 string끼리 더하거나, string.Format(), 문자열 보간($”{}”)등 이용 가능하지만 C는 그런거 없음.
    - 대신 서식 문자(format specifier) 이용.

## 주석
---
![[Untitled 4 2.png|Untitled 4 2.png]]
- /* */만 지원(C89 기준)
- 주석이 한 줄이든 여러 줄이든 다 /* */
- 다른 언어에서는 여러줄엔 /* */, 한 줄에는 //를 쓰는게 일반적이지만, C는 그렇지 않다.

  

## C는 절차적 언어
---
- C는 순수하게 절차적 언어로만 사용 가능하다.
- 즉, C로 작성한 언어는 데이터보다는 프로세스에 중점이 맞춰져있음.
    - 개체는 데이터와 기능을 모아둔 것이다. 즉 OOP에서 좀 더 강조되는 것들.
- 이게 반드시 나쁜건 아님. 절차적 언어는 이해하기 쉬움.
    - 순서대로 명령어를 실행하는 것이 바로 컴퓨터가 명령어를 실행하는 방식. 추상적인 개념이 적다.
    - OOP 언어에서도 종종 절차적 언어 스타일로 코드를 작성.
- 기능이 간단함.
    - 클래스 없음.
    - 함수
        - 모두 전역 함수.
    - 변수
        - 함수 밖에 선언되어있으면 전역변수.
        - 함수 안에 선언되어있으면 지역변수.
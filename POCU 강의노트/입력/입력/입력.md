---
Created: 2024-02-06T14:36:00
Updated: 2024-02-06T14:36:00
Course: COMP2200
tags:
  - Best_Practice
Reviewed: false
---
## 입력
---
- 출력의 반대
	- 외부의 데이터를 읽어와서 프로그램에서 사용
- 어떤 데이터가 들어올지 몰라 출력보다 어려움
- 데이터 읽기에 실패했는데 제대로 처리 안 하면 터짐
	- 그래서 모든 입력 함수에는 반환값이 있음
	- 따라서 어떤 함수가 어떤 값을 반환하는지 문서에서 확실히 읽고 코드에서 검사해야함
	- 대부분의 입력 처리 코드의 문제는 반환값이 뭔지 문서를 제대로 안 읽어봐서 발생함.
- 입력은 문서를 보면서 코딩하자.
### 입력의 출처
- 스트림
	- 콘솔, 파일 등등
- 문자열
	- 문자열에 출력(저장)했으니 읽어오는 방법도 있음.
- 출력과 마찬가지로 어디로 출력하든 거의 비슷한 함수가 있음
### 입력처리 전략
- 크게 네 가지 전략이 있음
	1. 한 글자씩 읽기
	2. 한 줄씩 읽기
	3. 한 데이터씩 읽기
		- 데이터 형에 맞추어 읽기
	4. 한 블록씩 읽기(이진 데이터)

## 한 글자씩 읽기
---
- 대략의 알고리듬
	1. 한 글자를 읽어온다.
	2. 그 글자를 필요한 곳에 사용한다.
	3. 1로 돌아간다.
```c
#include <stdio.h>

int main(void)
{
    int c;
    while(1)
    {
        c = getchar();
        putchar(c);
    }
}
```
- 동작
	1. getchar()가 아직 반환 안 함. 대기중.
	2. 키보드로 'a'입력 후 엔터키 누름
	3. 버퍼로부터 한 글자 읽어옴
	4. 읽은 문자 출력
	5. 더 이상 버퍼에 문자가 없으므로 1로 돌아감.
### getchar()
```c
int getchar(void);
int fgetc(FILE* stream);
```
- 키보드(stdin)으로부터 문자를 하나 읽어서 int형으로 반환
	- 굉장히 많은 입출력 함수들이 문자를 읽고 쓸 때 char 대신 int 씀
- `fgetc(stdin)`과 동일
#### 읽는 것 멈추기
1. 특별한 키를 입력받았을 경우?
	- 메뉴 입력 받은 거 받을 때는 가능
	- 하지만 타자 프로그램 등에서 모든 키보드 문자를 허용할 때는 불가능
2. 어디에서도 사용 가능한 "입력 끝"을 나타내는 무언가
	- 반환형이 int인 것과 관련됨
	- `getchar()`의 반환값은 성공하면 문자를, 실패하면 EOF를 반환함!
### EOF
- C 표준에 의하면 EOF는 음수.
- 표준에 따르면 [[../../C 기본 문법&빌드 단계/C 자료형/C 자료형#char|char]]는 부호가 있을 수도 있고 없을 수도 있음
	- 따라서 char에 이 음수 값을 담는 것이 불가
- 이것이 `getchar()`가 int를 반환하는 이유
- EOF는 ctrl 키와 다른 키를 조합하여 입력 가능
	- 윈도우: `ctrl + z`
	- UNIX-like 시스템: `ctrl + d`
### 완성된 코드
- 제대로 된 알고리듬
	1. 한 글자를 읽어온다.
	2. 글자를 읽어오는데 실패했다면 프로그램을 종료
	3. 아니라면 그 글자를 필요한 곳에 사용한다.
	4. 1로 돌아간다.
```c
#include <stdio.h>

int main(void)
{
    int c;

    c = getchar();

    while(c != EOF)
    {
        putchar(c);
        c = getchar();
    }
}
```
- `getchar()`가 두 번 있음
	- do while로는 해결 불가. while 검사 전에 c를 사용하기 때문.
	- 아래의 코드로 한 번으로 줄일 수 있다!
```c
#include <stdio.h>

int main(void)
{
    int c;

    while((c = getchar()) != EOF) {
        putchar(c);
    }
}
```
- 괄호 묶기 등 한 줄로 줄이는 것인 실수하기 쉬워서 요즘 다른 언어에선 잘 안 하기는 함
### 한 글자씩 읽는 방법이 유용한 경우
- 가장 간단한 방법
- 입력이 문자/문자열일 때 매우 좋음
- 쓸데없이 메모리에 입력값을 저장해두지 않아도 됨
	- 용량 절약
	- 실수 줄임
- O(N)
	- for 딱 한 번만 도는 알고리즘에 적합
	- 키보드로부터 한 글자씩 읽어서 곧바로 처리
- 그러나 다른 데이터형으로 쓰기는 좀 어려움
	- 예: 정수형 숫자 1004를 읽기
		- 4번 읽어서 정수로 변환하긴 좀...

## 한 줄씩 읽기
---
- 매우 중요함
- 이 것과 한 데이터씩 읽어오는 것을 합치면 매우 막강해짐
- 알고리듬
	1. 한 줄을 읽어온다
	2. 실패하면 프로그램 종료
	3. 아니면 한 줄 읽어온 데이터를 필요에 따라 사용
	4. 1번으로 되돌아감
 - 한 줄 읽어오면 어디에 저장해야 하지?
	- 한 줄 읽어오는 함수가 새로운 문자열을 메모리 잡아 반환해주지 않음
	- [[../../C 스타일 문자열/문자열 조작/문자열 조작#문자열 찾기#프로토타입|strstr]] 함수에서 설명함.
	- 따라서 프로그래머가 미리 만든 배열을 함수에 전달
	- 함수는 그 배열에 한 줄을 읽어옴
### gets(): 쓰지 마라
```c
char* gets(char* str);
```
- stdin에서 \\n 또는 EOF를 만날 떄까지 계속 문자를 읽어서 str에 저장
- 마지막 문자 바로 다음에 널문자도 넣어줌
- stdin에서 \\n을 제거하지만 버퍼에 저장하지는 않음
- 성공시 str, 실패시 NULL(포인터. 널문자 아님) 반환
```c
#define LINE_LENGTH (64)

char line[LINE_LENGTH];
while(gets(line) != NULL) {
	puts(line);
}
```
- 매우매우매우 위험한 함수
	-  만약 64자 이상 입력하면?
		- 버퍼 오버플로
	- 버퍼 길이를 늘려봤자, 사용자가 버퍼 오버플로를 일으키기로 마음먹으면 통제가 불가능함.
	- 올바르지 않은 메모리 주소게 키보드로 입력받은 값을 써버림
	- 잘못 접근해서 베이스 포인터와 돌아갈 함수 주소까지 다 바꿔버릴 수 있음
		- 돌아갈 함수 주소를 바꾼다? 
			- 권한과 무관하게 내가 실행하려는 아무 주소나 실행할 수도 있겠네?
	- 권한을 나타내는 변수를 덮어 씌워버릴 수도 있음.
	- 버퍼 오버플로우 공격.
	- ==절대절대절대 쓰지 말자.==
- C11에서는 아예 이 함수를 제거해버림
- 최신 헤더 파일에는 gets()가 더이상 존재하지 않음
	- 굳이 쓰려면 직접 함수 원형을 전방선언할 것. 그러나 쓰지 말자.
### fgets(): 안전하게 한 줄 읽기
```c
char* fgets(char* str, int count, FILE* stream);
```
- <stdio.h>
- 최대 count - 1개의 문자열을 읽어서 str에 저장
	- 널 문자를 포함하여 count개
- 즉, 새 줄을 만나지 않아도 이 함수가 반환될 수 있음
- str에 새 줄 문자(\\n)까지 넣어줌
	- 새 줄을 만나서 끝났을 때랑 아닐 때를 구분해야 하기 때문
	- 이게 gets()와 동작 방식이 다른 이유.
- `FILE*`
	- 스트림을 제어하기 위해 필요한 정보를 담고 있는 자료형
	- 정보?
		- 파일 위치 표시자
		- 스트림이 사용하는 버퍼의 포인터
		- 읽기/쓰기 중에 발생한 오류를 기록하는 오류 표시자
		- 파일의 끝에 도달했음을 기록하는 EOF 지시자
	- 플랫폼마다 구현 방식은 다를 수 있음
		- 직접 조작하려고는 하지 말 것.
	- 입력 및 출력 스트림은 오직 FILE 포인터로만 접근 및 조작 가능
- 반환값: gets()와 동일
	- 성공시 str, 실패시 NULL 포인터
#### 한 줄 읽기 예
```c
#include <stdio.h>

#define LINE_LENGTH (10)

int main(void)
{
    char line[LINE_LENGTH];

    while(fgets(line, LINE_LENGTH, stdin) != NULL) {
        printf("%s", line);
    }
}
```
- 스트림에 남아있는 문자들을 계속 읽다가 \\n을 만나고 새 줄 문자까지 line에 넣음
	- 다시 읽을 때 그 전의 내용들을 지우지는 않음.
	- 초기화도 필요 없음.
- 언제나 배열의 크기는 충분히 잡을 것
	- 충분히 길게 잡아 한 줄을 충분히 입력 받을 수 있도록 하는 경우가 보통.
	- 1024까지 잡는 경우도 있음. 이 정도면 보통 충분.
- 참고로 여기서는 puts() 쓰면 안 됨.
	- gets()로 읽어온 경우에는 puts() 써도 무관. 알아서 한 줄 띄워주기 때문.
### 한 줄씩 읽는 방법이 유용한 경우
- 일단 단어 하나씩 읽는 것보단 한 줄씩 읽는 것이 빠름
- CPU를 벗어나 외부 구성요소로부터 뭔가 읽어올 때는 한번에 많이 읽어오는 것이 빠름
- 따라서 버퍼 크기는 충분히 큰 것이 좋다
	- 하지만 당연히 버퍼 오버플로는 없어야 함.
- 이 자체로 의미가 있기보다 '한 데이터씩 읽어올 때' 쓸 일 많음
	- 안전하게 사용하기 위해

## 한 데이터씩 읽기
---
- 출력에서는 여러 자료형을 이쁘게 출력해주는 함수가 있었음
	- `printf()`
- 읽는 것도 가능함
	- `scanf()`
- 세 가지 버전 있음
	- `scanf(const char* format, ...)`: stdin으로부터 읽음
	- `fscanf(FILE* stream, const char* format, ...)`: 파일 스트림으로부터 읽음
	- `sscanf(const char* buffer, const char* format, ...)`: c 스타일 문자열로부터 읽음
### stdin에서 정수 읽기
```c
#include <stdio.h>

#define LINE_LENGTH (10)

int main(void)
{
    int num;

    printf("Enter a number: ");
    scanf("%d", &num);
    printf("num = %d\n", num);

    return 0;
}
```
- 주소를 전달함. 참조에 의한 전달 흉내.
- scanf()의 반환값
	- 몇 개의 데이터를 읽었는지 반환
	- 첫 데이터를 읽기 전에 실패했다면 EOF 반환
### 일반적인 서식 문자열 형식
```
%[*][너비][길이]서식지정자
```
#### 서식지정자

| % | %를 순수하게 문자로 인식 |
| ---- | ---- |
| c | 문자 |
| s | 한 단어 |
| d | 부호 있는 10진수 수 |
| x | 부호 없는 16진수 수 |
| f | 부동소수점 |

- 반드시 넣어야 함
- 모든 데이터는 한 단어씩(공백 문자로 구분) 또는 가능할 때까지 읽음
- 공백 문자는 버림(예외: %c)
#### 대입 생략 문자 \*
- 이 문자를 쓸 경우 키보드로부터 받은 입력을 변수에 저장하지 않음
#### 너비
- 읽을 최대 문자 수
	- %s의 경우 너비를 지정 안 하면 버퍼 오버플로가 날 수 있음
	- 다만 더 나은 방법이 뒤에 있음.
- 너비 지정 후 여러 문자를 한번에 읽으면 굉장히 애매해짐.
#### 길이수정자
- 인자의 바이트 크기 지정
- 출력과 마찬가지로 큰 의미는 없다.

### scanf 작동
- 공백은 무시
- 읽어올 수 있는 곳까지 읽고 서식 문자열과 일치하지 않을 경우 읽어오지 않음
	- 읽어오지 않은 부분부터는 입력 스트림에 남아있음

### scanf의 문제점과 해결책
- %s 쓸 때 배열 크기보다 큰 문자열이 들어오면 버퍼 오버플로
	- 문자열 읽어올 때 쓰지 말자
	- 버퍼 오버플로 어택 가능
- 숫자만 읽어야 하는데 문자를 읽어야 하는 경우도 있음
	- 뿐만 아니라 다른 자료형 읽을 때도 툭하면 입력 스트림에 남아있는 것을 계속 읽으려 하는 무한루프에 빠질 수 있음.
- 해결법은 fgets()와 sscanf() 함수를 같이 쓰는 것이 좋다.
```c
#define LINE_LENGTH (1024)

int sum = 0;
int num;
char line[LINE_LENGTH];

while(TRUE) {
    if(fgets(line, LINE_LENGTH, stdin) == NULL) {
        clearerr(stdin);
        break;
    }

    if(sscanf(line, "%d", &num) == 1) {
        sum += num;
    }
}
```
- 이 방법으로는 버퍼 오버플로가 발생하지 않는다.
	- 긴 문자열이 들어오면 그냥 짤리는 게 전부
### clearerr()
```c
void clearerr(FILE* stream);
```
- 스트림을 읽거나 쓸 때 EOF를 만나면 EOF indicator가 세팅됨
- 그 외의 이유로 실패하면 error indicator 세팅
- 그게 안 지워져서 다음에 읽거나 쓸 때 계속 실패할 수 있음
- 그래서 그 오류를 지워주는 것
- 표시자 세팅 여부는 ```feof()``` 혹은 ```ferror()``` 사용
### 한 데이터씩 읽는 방법이 유용한 경우
- 텍스트를 다른 자료형으로 곧바로 읽어오는 가장 간단한 방법
- 사용자 입력 받을 때 가장 많이 쓰는 방
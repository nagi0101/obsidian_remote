---
Created: 2023-12-18T13:31:00
Updated: 2023-12-18T13:31:00
Course: COMP2200
Tags:
  - Grammar
Reviewed: false
---
- [[#연산자|연산자]]
- [[#sizeof()|sizeof()]]
	- [[#sizeof()#size_t|size_t]]
	- [[#sizeof()#크기|크기]]
	- [[#sizeof()#용도|용도]]
		- [[#용도#size_t와 -1|size_t와 -1]]
	- [[#sizeof()#배열의 크기|배열의 크기]]
- [[#역참조 연산자 *|역참조 연산자 *]]
- [[#주소 연산자 &|주소 연산자 &]]
- [[#구조체, 공용체 멤버 접근자 .와 ->|구조체, 공용체 멤버 접근자 .와 ->]]
	- [[#구조체, 공용체 멤버 접근자 .와 ->#. 연산자|. 연산자]]
	- [[#구조체, 공용체 멤버 접근자 .와 ->#-> 연산자|-> 연산자]]


## 연산자

---
- 우선순위가 다른 연산자끼리 사용했을 경우 우선순위가 높은 연산자부터 적용.
- 우선순위가 같은 연산자끼리 사용했을 경우 연산자 결합 법칙의 순서로 적용.
- 피연산자 자리에 함수들이 있을 경우 ==함수 평가 순서는 연산자 결합 순서와 다를 수 있음==.
    - f() + g() * h() 라는 코드가 있을 때, 평가의 순서는 g→h→f가 아닐 수 있음.
- 대부분 다른 언어와 비슷하므로 C에서만 있는 몇 가지 연산자들만 알아보고 넘어가자.

## sizeof()

---

```C
char ch = 'a';
int num = 100;
char char_array[30];

size_t size_char = sizeof(ch);          /* 1 */
size_t size_int = sizeof(num);          /* 4 */
size_t size_float = sizeof(float);      /* 4 */
size_t size_array = sizeof(char_array); /* 30 */
```

- 피연산자의 크기를 바이트로 반환해주는 연산자.
- 함수가 아니다.
    - 런타임이 아니라 컴파일 타임에 판단됨
    - 컴파일 할 때 모르는 크기는 찾아줄 수 없음
    - char형을 넣으면 반드시 1 반환
    - 이 연산자가 반환하는 값은 부호없는 정수형의 상수로 size_t형

### size_t

- 부호 없는 정수형이나 실제 데이터형은 아님.
- _t는 typedef를 했다는 힌트.
    - typedef는 다른 자료형에 별칭을 붙이는 것.
    - 플랫폼에 따라 다른 자료형을 쓰기 위해서 size_t를 typedef 함.

### 크기

- C89 표준은 size_t의 크기를 딱히 명시하지 않음.
- 단, 배열을 만들면 그 배열의 바이트 크기를 얻을 수 있다고 명시함.
    - 즉, size_t는 최소 그 정도는 담을 수 있다는 크기.
    - 8비트는 너무 작을 것이고, 적어도 16비트는 되어야 할 것 같다.
    - C99 표준에서는 확실히 최소 16비트를 요구함.
- 보통은 unsigned int를 사용.

### 용도

- 어떤 것의 크기를 나타내기 위해 사용
    
    - 좋은 예: 반복문이나 배열에 접근할 때 사용
        - 반복문의 카운터 변수에 음수가 필요 없을 때.
        - 배열의 경우 길이가 음수가 될 수 없음.
    
    ```C
    int int_array[30];
    size_t i;
    
    for(i = 0; i < 30; ++i) {
    	/* unsigned, signed 형변환 주의. */
    	int_array[i] = (int)i;
    }
    ```
    

#### size_t와 -1

- C#의 IndexOf()함수가 문자를 못 찾으면 -1을 반환함.
- size_t를 가지고도 마찬가지 일을 할 수 있음.
- -1의 비트 패턴 = size_t의 최댓값의 비트 패턴
- size_t의 가장 큰 정수값이 반환되면 그것을 유효하지 않는 배열 색인으로 작성하는 경우가 흔함. 
    
    ```C
    size_t get_students_index(const char* name)
    {
    	if(!/* 조건 */) {
    		return (size_t)-1;
    	}
    	return 올바른_인덱스;
    }
    ```
    
    - 만약 size_t의 최댓값이 마침 올바른 배열 색인 값이라면?
        - 그럴 수도 있기는 하지만…
        - -1을 int로 반환하는 함수를 쓰면 배열의 최대 크기가 size_t로 사용할 수 있는 만큼의 반토막이 남.
        - 배열의 크기를 두 배로 늘렸을 때 그것의 마지막 값에 도달하는 것을 걱정한다면, 그걸 반토막 냈을 때 그걸 넘어가는 걱정을 먼저 해야함.
        - int형 -1을 반환하게 짠다면 확실하지만, 실용적인 것은 size_t의 최댓값을 반환하는 것.

### 배열의 크기

- 배열의 경우, 함수 인자로 받을 경우 다른 결과가 나옴.
    
    ```C
    size_t get_char_array_size(char data[])
    {
    	return sizeof(data);
    }
    
    int main(int argc, char** argv)
    {
    	char char_array[30];
    
    	size_t size_array = sizeof(char_array);                /* 30 */
    	size_t size_array_2 = get_char_array_size(char_array); /* 4, but 8 in 64bit system */
    
    	return 0;
    }
    ```
    

  

## 역참조 연산자 *
---

```C
int num = 10;
int* p = &num;            /* 포인터 변수 선언. 역참조 연산자 x */
int num1 = *p;            /* 역참조 연산자 */

int result = num1 * num2; /* 곱셈 연산자 */
```

- 피연산자가 하나일 때는 역참조 연산자.
- 포인터형 변수에만 사용 가능.
- 포인터형 변수에 저장된 주소의 위치에 들어있는 값에 접근

## 주소 연산자 &
---

```C
int num = 10;
int* p = &num;            /* 주소 연산자 */

int still_num = num1 & num2; /* 비트 연산자 */
```

- 피연산자가 하나일 때는 주소 연산자.
- 어떤 변수의 메모리 주소를 반환.

## 구조체, 공용체 멤버 접근자 .와 ->
---

### . 연산자

- 다른 언어에서는 클래스와 쓰이는 그 연산자. 그러나 C에는 클래스가 없으므로 함수 호출에 쓸 수 없음.
- 단, 구조체와 공용체의 멤버 변수에 접근할 때 사용.

### -> 연산자

- 2개의 연산자 ‘.’와 ‘*’를 합친 것.
- 이 또한 구조체와 공용체 멤버변수에 접근할 때 사용.
---
Created: 2023-12-18T14:02:00
Updated: 2023-12-18T14:02:00
Course: COMP2200
Tags:
  - Grammar
Reviewed: false
---
- [[#배열|배열]]
- [[#어떻게 new 없이 돌지?|어떻게 new 없이 돌지?]]
- [[#배열 요소 갯수 구하기|배열 요소 갯수 구하기]]
	- [[#배열 요소 갯수 구하기#매개변수 배열의 길이 사용하기|매개변수 배열의 길이 사용하기]]
- [[#배열 요소 초기화|배열 요소 초기화]]
	- [[#배열 요소 초기화#배열 요소 초기화 방법|배열 요소 초기화 방법]]
- [[#위험한 경우|위험한 경우]]
- [[#다차원 배열|다차원 배열]]


## 배열
---
```C
size_t i;
int nums[5] = { 1, 2, 3, 4, 5 };
char name[10];
float GPAs[3] = { 3.1f, 2.2f, -13.f };

for (i = 0; i < 5; ++i) {
	nums[i] += i * 2;
}
```

- new로 생성할 필요 없음. (사실 new 키워드 자체가 없음)
- 접근은 다른 언어들과 동일

## 어떻게 new 없이 돌지?
---
- C# 등에서는 배열은 기본 자료형이 아니라 new로 생성해서 참조형으로 썼었음.
    - 그래서 복사도 안 되었다.
- C는 참조형이 아닌 값형으로 배열을 만들 수 있다.
    - 사실 모든 자료형은 값형으로도 참조형으로도 만들 수 있음.
    - 값형으로 생성할 경우 [[../스택/스택]]에 할당된다. 해당 페이지 참고.

## 배열 요소 갯수 구하기
---
```C
/* 쉽게 쓸 수 있는 꼼수들. */
/* 단, 매개변수로 들어온 배열의 경우엔 사용 불가능한 방법임. */

/* 방법 1 */
const size_t num_vals = sizeof(values) / sizeof(values[0]);

/* 방법 2 */
\#define ARRAY_LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))

const size_t num_vals2 = ARRAY_LENGTH(values);
```

- sizeof()가 매개변수로 들어온 배열의 총 바이트 수를 반환할 수 있으려면 그 배열의 모든 요소가 스택에 다 복사되어 전달돼야 한다.
    - 그리고 호출되는 함수는 스택에 복사된 모든 요소의 크기를 정확히 알아야 함.
- 근데 이건 말이 안 됨. 그렇다면 같은 함수를 호출하는데도 매개변수 전달에 사용하는 스택의 크기가 달라야 한다는 뜻. 즉, 불가능하다. 
- 함수의 스택 메모리 사용량은 고정되어 있다.
    - 함수는 호출자가 누구든 간에 딱 정해진 수와 크기의 매개변수가 들어온다는 가정으로 동작.
    - 아래와 같은 경우도 그저 프로그래머의 편의를 위해 배열의 길이를 표시할 수 있게 했을 뿐임. 컴파일하면 길이를 안 넣은 것과 동일하게 나온다.
        
        ```C
        void process(int num[5]) {
        	size_t i;
        	for (i = 0; i < 5; ++i) {
        		nums[i] *= 2;
        	}
        }
        ```
        
        - 외부에서 전혀 다른 크기의 배열을 넣어도 작동은 함.
    - 함수가 먼저 결정되고, 호출자는 그 함수를 호출할 뿐.
    - 함수는 호출자가 뭐하는 놈인지 모름.
- 따라서 배열을 매개변수로 전달할 때는 실제 모든 요소를 스택에 넣지 않음
    - 그 대신 그 배열의 시작 위치를 스택에 넣어줌.
    - 이 주소의 크기 = 포인터 데이터형의 크기
    - 그래서 sizeof()를 하면 배열의 크기가 아닌 포인터의 크기가 나온다.
- 배열의 포인터를 전달하기 때문에 함수 내에서 배열의 값을 변경할 경우 원본 배열의 값이 바뀐다는 것에 주의.
    - 혹자는 이것을 “참조에 의한 호출”이라 함.(원본을 바꾸니까)
    - 혹자는 이것을 “값에 의한 호출”이라 함.(주소를 복사하니까)
    - 어떤 사람은 C에 참조에 의한 호출이 없고 그냥 주소를 전달하는 방법을 통해 “참조에 의한 호출을 시뮬레이션 하는 방법”이라고 말함
    - 뭐라 부르던 중요하지 않다. 원본이 바뀐다는 것만 알자.

### 매개변수 배열의 길이 사용하기
- 매개변수 배열의 길이를 알 방법은 없다!
    - 배열 자체에서 크기를 알아올 수 있는 방법은 없음.
- 아까와 같은 함수는 이렇게 작성해야 한다.
    
    ```C
    void process(size_t n, int num[5]) {
    	size_t i;
    	for (i = 0; i < n; ++i) {
    		nums[i] *= 2;
    	}
    }
    ```
    

## 배열 요소 초기화
---
- C는 배열 요소의 값을 초기화해주지 않는다. (C#은 0으로 해줌)
- 따라서 그 전에 그 메모리에 남아있던 값을 그대로 사용한다.
    - 이것은 다른 변수도 마찬가지.

### 배열 요소 초기화 방법

```C
int nums1[4]; /* 쓰레기값 */
int nums2[4] = { 10, 15, 3, -1 }; /* 모두 초기화됨 */
int nums3[4] = { 10, 15 }; /* 10, 15, 0, 0 */
int nums4[2] = { 10, 15, 3 }; /* 컴파일 오류 */
int nums5[] = { 10, 15, 3 }; /* 배열의 크기 = 3 */
```

- 베스트 프랙티스: 배열의 모든 값을 0으로 하려면
    
    ```C
    int nums[10] = { 0, };
    ```
    
    - ==0 뒤에 쉼표를 찍자.==
    - 이를 통해 초기화 목록이 모든 값을 직접 초기화해주진 않지만 쉼표 뒤가 모두 0으로 초기화됨을 보여줌

## 위험한 경우
---
- 초기화 안 된 지역변수를 사용하는 경우
	- 배열의 인덱스를 넘어가는 위치에 접근할 경우
- 버퍼 오버플로, memory stomp
    - 심지어 체크도 안 해줌.
    - memory stomp는 c, c++ 개발에서 고치기 가장 어려운 버그중 하나이니 조심하자…

## 다차원 배열
---

```C
int table[2][3];

for(int y = 0; y < 2; ++y)
{
	for(int x = 0; x < 3; ++x)
	{
		table[y][x] = (y + 1) * (x + 1);
	}
}
```

- 아래의 두 배열은 같다.

```C
int buffer[3][2];
int i;
int j;

for (i = 0; i < 3; ++i) {
	for (j = 0; j < 2; ++j) {
		buffer[i][j] = 0;
	}
}
```

```C
int buffer[3 * 2];
int i;
int j;

for (i = 0; i < 3; ++i) {
	for (j = 0; j < 2; ++j) {
		buffer[i * 2 + j] = 0;
	}
}
```

- 1차원 이상의 배열 역시 메모리에 값이 들어가는 모습은 동일하다.
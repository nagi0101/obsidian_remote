---
Created: 2024-01-30T10:23:00
Updated: 2024-01-30T10:23:00
Course: COMP2200
tags: 
Reviewed: false
---
## 문자열 비교
---
### 프로토타입
- 두 문자열을 비교하니 매개변수는 두 문자열 포인터
- 사전식 순서로 어떤 문자의 아스키코드가 더 작냐/같냐/크냐를 판별
	- ABCD는 ABCE보다 작다.
	- 소문자가 대문자보다 크다.
	- ABC는 ABCD보다 작다.
		- 순수하게 배열만 생각해도 '\\0'이 'D'보다 작음
- 반환값
	- 같으면 0
	- 좌항이 작으면 < 0
	- 좌항이 크면 > 0
	- 음수도 반환하니 반환형은 int
```c
int compare_string(const char* str0, const char* str1)
```
### 비교 알고리즘
1. 두 문자열에서 문자를 하나씩 읽음
2. 문자를 비교
	1. c0이 c1보다 작으면 음수 반환.
	1. c0이 c1보다 크면 양수 반환.
	2. (c0과 c1이 같고) 널 문자면 0 반환.
3. 다음 문자 이동 후 1번 단계로 돌아감.
```c
/* 방법 1 */
int compare_string(const char* str0, const char* str1)
{
        while(*str0 != '\0' && *str0 == *str1) {
                ++str0;
                ++str1;
        }

        return *str0 - *str1;
}

/* 방법 2 */
int compare_string(const char* str0, const char* str1)
{
        while(*str0 != '\0' && *str0 == *str1) {
                ++str0;
                ++str1;
        }

        if(*str0 == *str1) {
                return 0;
        }

        return *str0 > *str1 ? 1 : -1;
}
```
- 복잡한 로직을 간단히 작성하는 능력은 매우 중요하다.
	- 그런 능력이 없는 사람들은 길이 조건을 보고 그것을 따로 처리하는 코드를 작성함
	- 그러나 길이를 구할 때 사실상 for문을 한 번 더 돌리는 것임
	- 한번으로 되는 알고리즘을 굳이 더 느리게?
	- 데이터가 컴퓨터에 어떻게 저장되어 있는지를 알아야 이런 짓을 안 함.
### 표준함수
```c
int strcmp(const char* lhs, const char* rhs)
```

```c
#include <string.h>

const char* str0 = "AB";
const char* str1 = "AD";
int result = strcmp(str0, str1);
```
- 자매품 strncpy도 있음.
	- 최대 n문자까지 비교.

## 문자열 복사
---
```c
void copy_string(char* dest, const char* src)
{
        while( *src != '\0') {
                *dest++ = *src++;
        }

        *dest = '\0';
}

int main(void)
{
        const char* str1 = "Pope";
        char str2[5];
        copy_string(str2, str1);

        return 0;
}
```
- dest가 src보다 짧으면?
	- str1의 길이만큼 무작정 덮어쓰게 됨.
	- src와 dest의 크기를 확실히 통제하지 못하면 안전하지 못함.
	- C11에서는 보다 안전한 strcpy_s()가 나옴
### 표준 함수
```c
char* strcpy(char* dest, const char* src);
```
- <string.h>
- 반환값은 dest를 반환
	- 왜인진 모름. 실재로 아무도 안 씀.
- C11의 strcpy_s()는 errno_t를 반환

### 비교적 안전한 문자열 복사: srtncpy()
```c
char* strncpy(char* dest, const char* src, size_t count);
```
- 최대 count만큼 복사
- 널 문자를 먼저 만나면 그 전에 끝냄
1. src가 count보다 짧으면 남은 것을 다 0으로 채워줌
2. src가 count보다 길거나 같으면 count만큼 복사함
	- 널 문자를 붙일 곳이 없음
	- 따라서 안 붙여줌
- 그래서 프로그래머가 언제나 이렇게 코드 한 줄을 추가.
	- 0이 앞에 붙으면 거기서 어차피 멈춤.
	- 안 붙었으면 제일 마지막에 붙임.
	- 이런 습관을 들이자.
```c
strncpy(dest, src, DEST_SIZE);
dest[DEST_DIZE - 1] = '\0'; /* 추가 */
```
### strcpy() vs strncpy()
1. strcpy()보다 strncpy()가 보다 안전
	1. 두 크기를 확실히 통제할 수 있다면 strcpy도 안전
	2. strncpy 역시 여전히 위험한 경우 있음
		1. count가 src보다 길 경우 다 복사 후 널 문자가 없어 프로그래머가 붙여줘야 함
2. strncpy()가 보다 느림
	1. dest의 남은 요소를 0으로 채우기 때문

## 문자열 합치기
---
### strcat()
```c
char* strcat(char* dest, const char* src);
```
- src의 문자열을 dest 뒤에 덧붙이는 함수
	- dest의 널문자가 들어있는 위치부터 stc의 문자열 추가
	- 바꿔 말하면 dest의 널 문자가 src\[0]으로 교체
- dest의 길이가 충분해야 함
	- 이 길이를 넘어서 쓸 경우 정의되지 않은 결과 발생
### 보다 안전한 함수: strncat()
```c
char* strncat(char* dest, const char* src, size_t count);
```
- count개의 문자를 복사한 뒤, 널문자를 가장 마지막에 붙여줌
- 따라서 최대 count + 1개의 문자를 덮어씀.
- dest의 길이보다 길게 쓰면 마찬가지로 정의되지 않은 결과 발생
	- 그러나 count로 이러한 경우가 발생하지 않도록 프로그래머가 제어 가능
```c
#define DEST_COUNT (20)

const char* src = "POCU";
char dest[DEST_COUNT] = "Hi ";

strncat(dest, src, DEST_COUNT - strlen(dest) - 1);
```

## 문자열 찾기
---
### 없는 문자열을 찾는 경우
```c
#include <string.h>

int main(void)
{
        char msg[] = "I love string! I love C! I love programming!";

        char* result = strstr(msg, "int");
        /* printf("result: %s\n", result); */
        printf("result: %s\n", result == NULL ? "(null)" : result);

        return 0;
}
```
- 주석처리한 부분은 위험한 코드. 
	- result가 null 포인터인데 그것을 그냥 출력함. 정의되지 않은 동작.
### 프로토타입
```c
char* strstr(const char* str, const char* substr);
```
- <string.h>
- 반환값
	- substr이 str에 있다면: 해당 substr이 시작하는 주소
	- substr이 str에 없다면: 널포인터
- 매개변수 str은 const char\*인데 반환값은 char\*임.
	- 즉 strstr을 거치면 const의 의미가 사라짐.
	- 포인터를 받아와 쓰기를 수행할 경우 원본 문자열이 변경 가능한 문자열인 
	- 위의 예시 코드에서 str을 데이터섹션이 아니라 스택에 넣은 이유.
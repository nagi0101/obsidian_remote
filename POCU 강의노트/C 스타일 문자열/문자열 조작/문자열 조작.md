---
Created: 2024-01-30T10:23:00
Updated: 2024-01-30T10:23:00
Course: COMP2200
tags: 
Reviewed: false
---
## 문자열 비교
---
### 프로토타입
- 두 문자열을 비교하니 매개변수는 두 문자열 포인터
- 사전식 순서로 어떤 문자의 아스키코드가 더 작냐/같냐/크냐를 판별
	- ABCD는 ABCE보다 작다.
	- 소문자가 대문자보다 크다.
	- ABC는 ABCD보다 작다.
		- 순수하게 배열만 생각해도 '\\0'이 'D'보다 작음
- 반환값
	- 같으면 0
	- 좌항이 작으면 < 0
	- 좌항이 크면 > 0
	- 음수도 반환하니 반환형은 int
```c
int compare_string(const char* str0, const char* str1)
```
### 비교 알고리즘
1. 두 문자열에서 문자를 하나씩 읽음
2. 문자를 비교
	1. c0이 c1보다 작으면 음수 반환.
	1. c0이 c1보다 크면 양수 반환.
	2. (c0과 c1이 같고) 널 문자면 0 반환.
3. 다음 문자 이동 후 1번 단계로 돌아감.
```c
/* 방법 1 */
int compare_string(const char* str0, const char* str1)
{
        while(*str0 != '\0' && *str0 == *str1) {
                ++str0;
                ++str1;
        }

        return *str0 - *str1;
}

/* 방법 2 */
int compare_string(const char* str0, const char* str1)
{
        while(*str0 != '\0' && *str0 == *str1) {
                ++str0;
                ++str1;
        }

        if(*str0 == *str1) {
                return 0;
        }

        return *str0 > *str1 ? 1 : -1;
}
```
- 복잡한 로직을 간단히 작성하는 능력은 매우 중요하다.
	- 그런 능력이 없는 사람들은 길이 조건을 보고 그것을 따로 처리하는 코드를 작성함
	- 그러나 길이를 구할 때 사실상 for문을 한 번 더 돌리는 것임
	- 한번으로 되는 알고리즘을 굳이 더 느리게?
	- 데이터가 컴퓨터에 어떻게 저장되어 있는지를 알아야 이런 짓을 안 함.
### 표준함수
```c
int strcmp(const char* lhs, const char* rhs)
```

```c
#include <string.h>

const char* str0 = "AB";
const char* str1 = "AD";
int result = strcmp(str0, str1);
```
- 자매품 strncpy도 있음.
	- 최대 n문자까지 비교.

## 문자열 복사
---
```c
void copy_string(char* dest, const char* src)
{
        while( *src != '\0') {
                *dest++ = *src++;
        }

        *dest = '\0';
}

int main(void)
{
        const char* str1 = "Pope";
        char str2[5];
        copy_string(str2, str1);

        return 0;
}
```
- dest가 src보다 짧으면?
	- str1의 길이만큼 무작정 덮어쓰게 됨.
	- src와 dest의 크기를 확실히 통제하지 못하면 안전하지 못함.
	- C11에서는 보다 안전한 strcpy_s()가 나옴
### 표준 함수
```c
char* strcpy(char* dest, const char* src);
```
- <string.h>
- 반환값은 dest를 반환
	- 왜인진 모름. 실재로 아무도 안 씀.
- C11의 strcpy_s()는 errno_t를 반환

### 비교적 안전한 문자열 복사: srtncpy()
```c
char* strncpy(char* dest, const char* src, size_t count);
```
- 최대 count만큼 복사
- 널 문자를 먼저 만나면 그 전에 끝냄
1. src가 count보다 짧으면 남은 것을 다 0으로 채워줌
2. src가 count보다 길거나 같으면 count만큼 복사함
	- 널 문자를 붙일 곳이 없음
	- 따라서 안 붙여줌
- 그래서 프로그래머가 언제나 이렇게 코드 한 줄을 추가
```c
strncpy(dest, src, DEST_SIZE);
dest[DEST_DIZE - 1] = '\0' / 추가 /
```
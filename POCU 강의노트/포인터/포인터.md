---
Created: 2023-12-24T17:51:00
Updated: 2023-12-24T17:51:00
Course: COMP2200
tags:
  - Grammar
  - Best_Practice
Reviewed: false
---

- [[#주소 연산자 &|주소 연산자 &]]
- [[#메모리 주소 저장하기|메모리 주소 저장하기]]
- [[#포인터|포인터]]
	- [[#포인터#선언|선언]]
	- [[#포인터#실재 예|실재 예]]


- 메모리 주소를 가지고 그 주소의 값을 읽고 변경 가능
	- 쓸데 없는 복사를 최소화 할 수 있다
	- 다른 언어에서는 불가능한 일
- 양날의 검.
	- 잘 활용하면 매우 강력한 일들을 할 수 있다.
	- 그러나 동시에 매우 위험한 기능이기도 함.
	- 잘 사용하는 것이 중요하다. 열심히 익혀두자.

## 주소 연산자 &
---
```C
void print_address(void)
{
	int num = 10;
	printf("Address of num: %p\n", (void*)&num);
}
```
- 변수 앞에 &를 붙이면 해당 변수의 주소값을 얻어올 수 있다.
	- 위의 경우는 스택에 존재하는 num의 주소값을 얻어옴.
- 실행 결과 32비트 머신에서는 8자리 16진수 출력됨.
	- 요즘 운영체제는 보안 강화를 위해 실행 시킬때마다 주소를 바꾸어준다.
		- 컴파일러의 ASLR이라는 기능
	- 옛날 운영체제는 저 주소도 항상 같았음.

## 메모리 주소 저장하기
---
- 주소를 포함한 모든 데이터는 메모리에 저장됨.
- 그러나 그냥 int에 대입하면 컴파일 오류 발생. 
```C
int main(void)
{
    int num = 10;
    int num_address = &num;
    return 0;
}
```
![[Pasted image 20231225114259.png]]
- 사실 이게 가능해도 문제. 주소와 값을 구분하는 것은 매우 중요.
- 주소를 저장하기 위한 특별한 변수가 포인터.

## 포인터
---
- ==주소를 저장하기 위한 변수형.==
- 그 주소에 저장된 자료형은 하드웨어는 신경쓰지 않는다.
	- 비트 패턴을 char로 읽으면 char이고 int로 읽으면 int임.
- 그러나 해당 주소에서 몇 바이트를 읽어야 하는지를 하드웨어에 알려줘야함.
	- 때문에 포인터 변수를 선언할 때는 그 주소에 어떤 형의 데이터가 있는지 명시하기 위해 포인터 앞에 자료형을 붙임
### 선언
```C
int main(void)
{
    int num = 10;
    int* num_address = &num;
    return 0;
}
```
- ==코딩 표준: \*은 자료형에 붙인다.==
	- int \*address;도 가능.
	- 그러나 역참조랑 안 햇갈리려면 int* address;가 조금 더 나음.
- 읽는 법
	- int 포인터
	- pointer to an int
### 실재 예
| num_address | num |
|--|--|
| ![[Pasted image 20231225120447.png]] | ![[Pasted image 20231225120532.png]] |
- num_address에 저장된 주소에 num의 값(10)이 저장되어 있다.
- 왜 바이트 순서가 반대인지 모르겠다면 little-endian 참고.

## 역참조
---
- 역참조를 활용하여 포인터에 저장된 주소에 저장된 값에 접근 가능.
### 역참조 연산자 \*
```C
#include <stdio.h>

int main(void)
{
        int num = 10;
        int* num_address = &num;
        printf("%d\n", *num_address);

        return 0;
}
```
- 포인터가 저장하고 있는 메모리 위치로 가서 저장된 값에 접근
	- 접근: 읽거나 씀

### 참조와 역참조
- 참조
	- 포인터가 하고 있는 것
	- 어떤 변수의 값을 직접 가져다 쓰는 것이 아닌 어디에 있다고 '참조'
	- 즉, 값이 어디 있는지 가리키고 있는 것
- 역참조
	- 주소로 직접 가서 해당 값에 접근
	- 참조의 반대라서 역참조라고 함
	- 실제 데이터에 간접적으로 접근
		- 값에 직접 접근하지 않고 주소를 이용해 간접적으로 접근
		- 따라서 간접(indirect) 연산자라고도 함
	- 매우 중요한 개념이므로 반드시 숙지
		- 데이터를 복사하지 않고 원본에 접근 가능
		- 컴퓨터 구조에서 데이터를 오랫동안 메모리에 저장하는 방법
		- 눈에 보이지 않는 추상적인 개념을 이해하는 능력을 평가하는 가장 간단한 지표
			- 참고로 두 번째로 간단한 지표는 재귀함수 

### 역참조 활용하여 값 변경하는 예시
```c
#include <stdio.h>

int main(void)
{
        int num = 10;
        int* num_address = &num;
        printf("%d\n", *num_address);
        *num_address = 50;
        printf("%d\n", *num_address);

        return 0;
}
```

### 포인터 변수 선언 vs. 역참조
```c
    int score = 100;
    int* pointer = &score; /* 포인터 변수 선언 */
    *pointer = 50; /* 역참조 */
```
- 똑같이 \* 붙어있다고 같은 것이 아니다.
- 하나는 포인터 변수 선언, 하나는 역참조.
- 햇갈리지 않게 잘 기억하자.

### 포인터를 활용한 swap 함수
```c
void swap(int* arg1, int* arg2)
{
    int tmp;

    tmp = *arg1;
    *arg1 = *arg2;
    *arg2 = tmp;
}


int main(void)
{
    int num1 = 10;
    int num2 = 20;
    swap(&num1, &num2);

    return 0;
}
```

## 값에 의한 전달 vs. 참조에 의한 전달
---
- 원본이 바뀌니 -> 참조에 의한 전달
- 메모리 주소를 복사했으니 -> 값에 의한 전달
- 언어 구조적으아주 엄밀히 말하면 C는 언제나 변수를 복사함.
	- 모든 것이 값에 의한 전달.
	- 단, 포인터를 사용하여 참조에 의한 전달을 흉내낼 뿐임.
- 그러나 프로그래머 입장에서 가장 중요한 것은 원본이 바뀌는지 바뀌지 않는지임.
	- 때문에 의도를 따지자면 참조에 의한 전달이라 말하는 것이 차라리 나음.
- 
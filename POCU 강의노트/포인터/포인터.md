---
Created: 2023-12-24T17:51:00
Updated: 2023-12-24T17:51:00
Course: COMP2200
tags:
  - Grammar
  - Best_Practice
Reviewed: false
---


- 메모리 주소를 가지고 그 주소의 값을 읽고 변경 가능
	- 쓸데 없는 복사를 최소화 할 수 있다
	- 다른 언어에서는 불가능한 일
- 양날의 검.
	- 잘 활용하면 매우 강력한 일들을 할 수 있다.
	- 그러나 동시에 매우 위험한 기능이기도 함.
	- 잘 사용하는 것이 중요하다. 열심히 익혀두자.

## 주소 연산자 &
---
```C
void print_address(void)
{
	int num = 10;
	printf("Address of num: %p\n", (void*)&num);
}
```
- 변수 앞에 &를 붙이면 해당 변수의 주소값을 얻어올 수 있다.
	- 위의 경우는 스택에 존재하는 num의 주소값을 얻어옴.
- 실행 결과 32비트 머신에서는 8자리 16진수 출력됨.
	- 요즘 운영체제는 보안 강화를 위해 실행 시킬때마다 주소를 바꾸어준다.
		- 컴파일러의 ASLR이라는 기능
	- 옛날 운영체제는 저 주소도 항상 같았음.

## 메모리 주소 저장하기
---
- 주소를 포함한 모든 데이터는 메모리에 저장됨.
- 그러나 그냥 int에 대입하면 컴파일 오류 발생. 
```C
int main(void)
{
    int num = 10;
    int num_address = &num;
    return 0;
}
```
![[Pasted image 20231225114259.png]]
- 사실 이게 가능해도 문제. 주소와 값을 구분하는 것은 매우 중요.
- 주소를 저장하기 위한 특별한 변수가 포인터.

## 포인터
---
- ==주소를 저장하기 위한 변수형.==
- 그 주소에 저장된 자료형은 하드웨어는 신경쓰지 않는다.
	- 비트 패턴을 char로 읽으면 char이고 int로 읽으면 int임.
- 그러나 해당 주소에서 몇 바이트를 읽어야 하는지를 하드웨어에 알려줘야함.
	- 때문에 포인터 변수를 선언할 때는 그 주소에 어떤 형의 데이터가 있는지 명시하기 위해 포인터 앞에 자료형을 붙임
### 선언
```C
int main(void)
{
    int num = 10;
    int* num_address = &num;
    return 0;
}
```
- ==코딩 표준: \*은 자료형에 붙인다.==
	- int \*address;도 가능.
	- 그러나 자료형을 안 햇갈리려면 int* address;가 조금 더 나음.
- 읽는 법
	- int 포인터
	- pointer to an int
- 실재 예
| | |
|:---|---:|
|  |  |

![[../../Pasted image 20231225115921.png]]
---
Created: 2023-12-24T17:51:00
Updated: 2023-12-24T17:51:00
Course: COMP2200
tags:
  - Grammar
  - Best_Practice
Reviewed: false
---
- [[#주소 연산자 &|주소 연산자 &]]
- [[#메모리 주소 저장하기|메모리 주소 저장하기]]
- [[#포인터|포인터]]
	- [[#포인터#선언|선언]]
	- [[#포인터#실재 예|실재 예]]
- [[#역참조|역참조]]
	- [[#역참조#역참조 연산자 \*|역참조 연산자 \*]]
	- [[#역참조#참조와 역참조|참조와 역참조]]
	- [[#역참조#역참조 활용하여 값 변경하는 예시|역참조 활용하여 값 변경하는 예시]]
	- [[#역참조#포인터 변수 선언 vs. 역참조|포인터 변수 선언 vs. 역참조]]
	- [[#역참조#포인터를 활용한 swap 함수|포인터를 활용한 swap 함수]]
- [[#값에 의한 전달 vs. 참조에 의한 전달|값에 의한 전달 vs. 참조에 의한 전달]]
- [[#포인터와 함수 반환값|포인터와 함수 반환값]]
	- [[#포인터와 함수 반환값#포인터를 반환해도 되는 경우|포인터를 반환해도 되는 경우]]
- [[#널 포인터|널 포인터]]
	- [[#널 포인터#문제점|문제점]]
		- [[#문제점#매개변수|매개변수]]
		- [[#문제점#반환값|반환값]]
	- [[#널 포인터#언제 사용하는가?|언제 사용하는가?]]
- [[#포인터의 비교|포인터의 비교]]
- [[#포인터의 크기|포인터의 크기]]
- [[#포인터와 ../C 기본 문법&빌드 단계/C 배열/C 배열 C 배열|포인터와 C 배열]]
	- [[#포인터와 ../C 기본 문법&빌드 단계/C 배열/C 배열 C 배열#배열 속 각 요소의 위치 계산|배열 속 각 요소의 위치 계산]]


- 메모리 주소를 가지고 그 주소의 값을 읽고 변경 가능
	- 쓸데 없는 복사를 최소화 할 수 있다
	- 다른 언어에서는 불가능한 일
- 양날의 검.
	- 잘 활용하면 매우 강력한 일들을 할 수 있다.
	- 그러나 동시에 매우 위험한 기능이기도 함.
	- 잘 사용하는 것이 중요하다. 열심히 익혀두자.

## 주소 연산자 &
---
```C
void print_address(void)
{
	int num = 10;
	printf("Address of num: %p\n", (void*)&num);
}
```
- 변수 앞에 &를 붙이면 해당 변수의 주소값을 얻어올 수 있다.
	- 위의 경우는 스택에 존재하는 num의 주소값을 얻어옴.
- 실행 결과 32비트 머신에서는 8자리 16진수 출력됨.
	- 요즘 운영체제는 보안 강화를 위해 실행 시킬때마다 주소를 바꾸어준다.
		- 컴파일러의 ASLR이라는 기능
	- 옛날 운영체제는 저 주소도 항상 같았음.

## 메모리 주소 저장하기
---
- 주소를 포함한 모든 데이터는 메모리에 저장됨.
- 그러나 그냥 int에 대입하면 컴파일 오류 발생. 
```C
int main(void)
{
    int num = 10;
    int num_address = &num;
    return 0;
}
```
![[Pasted image 20231225114259.png]]
- 사실 이게 가능해도 문제. 주소와 값을 구분하는 것은 매우 중요.
- 주소를 저장하기 위한 특별한 변수가 포인터.

## 포인터
---
- ==주소를 저장하기 위한 변수형.==
- 그 주소에 저장된 자료형은 하드웨어는 신경쓰지 않는다.
	- 비트 패턴을 char로 읽으면 char이고 int로 읽으면 int임.
- 그러나 해당 주소에서 몇 바이트를 읽어야 하는지를 하드웨어에 알려줘야함.
	- 때문에 포인터 변수를 선언할 때는 그 주소에 어떤 형의 데이터가 있는지 명시하기 위해 포인터 앞에 자료형을 붙임
### 선언
```C
int main(void)
{
    int num = 10;
    int* num_address = &num;
    return 0;
}
```
- ==코딩 표준: \*은 자료형에 붙인다.==
	- int \*address;도 가능.
	- 그러나 역참조랑 안 햇갈리려면 int* address;가 조금 더 나음.
- 읽는 법
	- int 포인터
	- pointer to an int
### 실재 예
| num_address | num |
|--|--|
| ![[Pasted image 20231225120447.png]] | ![[Pasted image 20231225120532.png]] |
- num_address에 저장된 주소에 num의 값(10)이 저장되어 있다.
- 왜 바이트 순서가 반대인지 모르겠다면 little-endian 참고.

## 역참조
---
- 역참조를 활용하여 포인터에 저장된 주소에 저장된 값에 접근 가능.
### 역참조 연산자 \*
```C
#include <stdio.h>

int main(void)
{
        int num = 10;
        int* num_address = &num;
        printf("%d\n", *num_address);

        return 0;
}
```
- 포인터가 저장하고 있는 메모리 위치로 가서 저장된 값에 접근
	- 접근: 읽거나 씀

### 참조와 역참조
- 참조
	- 포인터가 하고 있는 것
	- 어떤 변수의 값을 직접 가져다 쓰는 것이 아닌 어디에 있다고 '참조'
	- 즉, 값이 어디 있는지 가리키고 있는 것
- 역참조
	- 주소로 직접 가서 해당 값에 접근
	- 참조의 반대라서 역참조라고 함
	- 실제 데이터에 간접적으로 접근
		- 값에 직접 접근하지 않고 주소를 이용해 간접적으로 접근
		- 따라서 간접(indirect) 연산자라고도 함
	- 매우 중요한 개념이므로 반드시 숙지
		- 데이터를 복사하지 않고 원본에 접근 가능
		- 컴퓨터 구조에서 데이터를 오랫동안 메모리에 저장하는 방법
		- 눈에 보이지 않는 추상적인 개념을 이해하는 능력을 평가하는 가장 간단한 지표
			- 참고로 두 번째로 간단한 지표는 재귀함수 

### 역참조 활용하여 값 변경하는 예시
```c
#include <stdio.h>

int main(void)
{
        int num = 10;
        int* num_address = &num;
        printf("%d\n", *num_address);
        *num_address = 50;
        printf("%d\n", *num_address);

        return 0;
}
```

### 포인터 변수 선언 vs. 역참조
```c
    int score = 100;
    int* pointer = &score; /* 포인터 변수 선언 */
    *pointer = 50; /* 역참조 */
```
- 똑같이 \* 붙어있다고 같은 것이 아니다.
- 하나는 포인터 변수 선언, 하나는 역참조.
- 햇갈리지 않게 잘 기억하자.

### 포인터를 활용한 swap 함수
```c
void swap(int* arg1, int* arg2)
{
    int tmp;

    tmp = *arg1;
    *arg1 = *arg2;
    *arg2 = tmp;
}


int main(void)
{
    int num1 = 10;
    int num2 = 20;
    swap(&num1, &num2);

    return 0;
}
```

## 값에 의한 전달 vs. 참조에 의한 전달
---
- 원본이 바뀌니 -> 참조에 의한 전달
- 메모리 주소를 복사했으니 -> 값에 의한 전달
- 언어 구조적으로 엄밀히 말하면 C는 언제나 변수를 복사함.
	- 모든 것이 값에 의한 전달. C에는 참조에 의한 전달이 존재하지 않음.
	- 단, 포인터를 사용하여 참조에 의한 전달을 흉내낼 뿐임.
- 그러나 프로그래머 입장에서 가장 중요한 것은 원본이 바뀌는지 바뀌지 않는지임.
	- 때문에 의도를 따지자면 참조에 의한 전달이라 말하는 것이 차라리 나음.
- 그러니 포인터를 전달할 때는 참조에 의한 전달이라고 하자.

## 포인터와 함수 반환값
---
- 포인터도 변수이니 포인터를 반환 가능하다. 다만 잘못 쓰면 매우 위험하다.
- 지역 변수의 주소를 반환: 매우 위험한 코드
	- 이런 코드는 절대 짜면 안된다
```c
int* add(const int arg1, const int arg2)
{
    int result = arg1 + arg2;
    return &result;
}

int main(void)
{
    int* result;
    result = add(10, 20);
    return 0;
}
```
![[Pasted image 20231228140455.png]]
- 컴파일러가 경고는 주지만 에러를 일으키지는 않는다.
- 댕글링 포인터(dangling pointer)라는 문제. 
	- 실제로 존재하지 않는 대상을 가리키는 포인터를 의미함
### 포인터를 반환해도 되는 경우
	- 전역 변수
	- 파일 static 전역변수
	- 함수 내 static 변수
	- 도우미 함수 안에 생성한 변수를 다른 함수에서 사용할 때
		- but 지역변수는 안 됨
	- 함수 안에서 대용량의 데이터 생성 후 이를 반환할 때
		- 힙 메모리에 생성한 데이터

## 널 포인터
---
- 아무 것도 가리키지 않는 포인터
	- 함수가 반환할 주소가 없다면 이것을 반환하면 됨
- 값이 '0'인 상수 표현식 or void\*로 캐스팅된 표현식
- 전용 매크로가 있음
```C
#define NULL ((void*)0)

int main(void)
{
        int* result = NULL;
        return 0;
}
```
- 널 포인터를 표현할 때 이 매크로 사용하면 됨
- ==코딩 표준: 매크로 NULL을 반드시 사용할 것==
	- 0은 사용하지 않는다
	- NULL을 사용해야 가독성이 더 좋음. 변수가 포인터인 것을 나타낼 수 있음
```C
#define NULL ((void*)0)
#define PRICE (2)

void increase_price(int* current_price)
{
        if(current_price != NULL)
        {
                *current_price += PRICE;
        }
}
```

### 문제점
#### 매개변수
- 누구나 NULL을 넣을 수 있음
	-  예외 처리하는 코드를 모든 함수에 넣는 것은 함수의 본래 작동에서 꽤나 멀어짐
	- 때문의 함수의 선조건으로 해결하는 것이 좋음
- 기본적으로 NULL이 안 들어온다고 가정하고 함수를 작성할 것
	- NULL이 들어올 수 있는 함수는 매개변수명에서 명시하는 것이 좋음
- ==코딩 표준: 널 포인터를 허용하는 매개변수는 이름 끝에 '\_or_null'을 붙인다.
	- NULL이 안 들어온다고 가정하는 경우는 assert()로 검증
		- 디버그에서 잡는다.
```c
#include <assert.h>
#define NULL ((void*)0)
#define PRICE (2)

void increase_price(int* current_price)
{
        assert(current_price != NULL);
        *current_price += PRICE;
}

void get_score(const char* const student_id_or_null)
{
		/* 코드 생략 */
}
```
#### 반환값
- 선조건: 기본적으로 안 함
	- 호출하는 사람 입장에서 함수가 NULL을 반환하는 경우까지 예외 처리를 작성해야 할 경우 함수를 호출하는 코드가 너무 지저분해짐.
- ==코딩 표준: 반환을 해야한다면 함수 이름에 NULL을 명시할 것==
```c
#define NULL ((void*)0)

const char* get_name_or_null(const int id)
{
        /* 코드 생략 */
        return NULL;
}
```

### 언제 사용하는가?
1. 포인터 변수를 초기화하고 싶을 때
	- 아직 참조할 주소가 없을 경우
	- 비교가 일어나지 않을 경우 성능이 중요하면 초기화 안 하기도 함
1. 포인터 변수가 유효한 주소룰 참조하고 있는지 확인하고 싶을 때
	- 아무것도 가리키지 않는 포인터를 참조?
		- undefined behavior
	- 역참조 전에 널포인터 확인할 것
1.  댕글링 포인터 방지
	 - 동적 메모리 해제시 포인터는 댕글링 포인터가 됨
	 - 이를 널 포인터로 리셋해야 함
> [!NOTE] 잊지 말자!
> 결과적으로 존재하지 않는 메모리 주소에 접근해서 값을 읽거나 쓰면 문제가 펑펑 터진다!

## 포인터의 비교
---
- 위에서 NULL과의 비교와 같이 포인터 변수도 비교 가능
	- \==, >, <, != 등등...

## 포인터의 크기
---
- 모든 포인터는 동일한 크기
- 크기는 코드를 컴파일하는 시스템 아키텍쳐에 따라 결정됨
	- 보통 워드 크기와 동일

## 포인터와 [[../C 기본 문법&빌드 단계/C 배열/C 배열|C 배열]]
---
- 배열을 매개변수로 넘기면?
	- 첫 번째 요소의 메모리 주소가 복사되며
	- 그 크기는 보통 시스템 워드 크기와 동일
- 즉, 포인터와 같다.
```c
#define NULL ((void*)0)

int main(void)
{
        int arr[] = { 0, 1, 2, 3, 4 };
        int* ptr1 = arr;
        int* ptr2 = &arr[0];
        /* int* ptr3 = arr[0]; */ /* 컴파일 에러 */

        return 0;
}
```

### 배열 속 각 요소의 위치 계산
- 배열 속 각 요소 사이의 바이트 간격은 자료형 크기로 일정
- 즉 시작 위치와 자료형 크기만 알면 n번째 요소의 주소 알 수 있음
- 포인터에 정수1를 더하면?
	- 포인터의 위치를 다음 데이터의 위치로 이동
	- 1 바이트를 더하는 것이 아님.
		- 데이터 바이트 크기만큼 증가.
	- 뺄셈, ++, --도 마찬가지.
- 즉 index를 배열 주소를 저장하는 포인터에 더하면 해당 인덱스의 주소가 나옴
- 아래의 세 표현식은 컴파일러에게 똑같은 의미
	- nums\[1]
	- ptr\[1]
	- \*(ptr + 1)
- 포인터 매개변수로 배열을 받는 것도 가능
- 정말 딱 '한' 바이트만 옮기고 싶으면 char\*로 캐스팅 후 증가시키면 됨

## 두 주소 사이의 사칙연산
---
- 소숫점 더할 수 없음
	- 주소는 정수
- 뺄셈을 제외한 덧셈, 곱셈, 나눗셈 불가능
- 뺄셈의 경우 두 주소 사이에 들어갈 수 있는 데이터 수를 반환함.
	- 따라서 포인터가 아니라 ==정수를 반환==
	- 배열의 첫 요소의 주소와 마지막 요소의 주소를 알면 배열의 크기 구할 수 있음 

---
Created: 2024-01-03T17:54:00
Updated: 2024-01-03T17:54:00
Course: COMP2200
tags: 
Reviewed: false
---
- [[#두 주소 사이의 사칙연산|두 주소 사이의 사칙연산]]
- [[#포인터와 ../C 기본 문법&빌드 단계/C 연산자/C 연산자 C 연산자 결합법칙|포인터와 C 연산자 결합법칙]]
	- [[#포인터와 ../C 기본 문법&빌드 단계/C 연산자/C 연산자 C 연산자 결합법칙#동일한 우선순위를 갖는 연산자|동일한 우선순위를 갖는 연산자]]
	- [[#포인터와 ../C 기본 문법&빌드 단계/C 연산자/C 연산자 C 연산자 결합법칙#조금 더 빠른 배열의 요소 접근|조금 더 빠른 배열의 요소 접근]]


## 두 주소 사이의 사칙연산
---
- 소숫점 더할 수 없음
	- 주소는 정수
- 뺄셈을 제외한 덧셈, 곱셈, 나눗셈 불가능
- 뺄셈의 경우 두 주소 사이에 들어갈 수 있는 데이터 수를 반환함.
	- 따라서 포인터가 아니라 ==정수를 반환==
	- 배열의 첫 요소의 주소와 마지막 요소의 주소를 알면 배열의 크기 구할 수 있음 
```c
int main(void)
{
        int arr[] = { 0, 1, 2, 3, 4 };
        int sub = &arr[4] - &arr[1]; /* 3 */
        return 0;
}
```

## 포인터와 [[../../C 기본 문법&빌드 단계/C 연산자/C 연산자|C 연산자]] 결합법칙
---
- 보통 연산자 결합 법칙은 별로 고민할 필요 없음
	- 익숙한 것들은 그냥 쓰고 아니면 괄호 치면 됨
- 근데 포인터와 관련된 연산자들이 좀 햇갈림
```c
    int num = *p++;
    int num = *++p;
    int num = ++*p
    int num = (*p)++;
```
- 첫 번째 경우는 후위연산자 ++가 \*보다 우선순위 높아서 결합법칙 생각할 필요도 없다
- 두 번째 경우는 \*와 전위연산자 ++가 우선순위가 같아 오른쪽에서 왼쪽으로 결합함. \*랑 ++는 합칠 여지도 없으니 ++p가 먼저.
- 세 번째 경우도 마찬가지. \*p가 먼저.
- 마지막은 쉬움. 괄호 먼저.
### 동일한 우선순위를 갖는 연산자
- 동일한 우선순위를 가지는 연산자들은 모두 같은 결합방향을 가진다
- C를 자주 쓰는 사람들은 암기, 아니라면 괄호를 쓰자. 실수를 예방할 수도 있고 포인터 없는 언어에 익숙한 사람도 읽기 편함.
### 조금 더 빠른 배열의 요소 접근
```c
int sum(int* start, int* end)
{
        int result = 0;
        int *p = start;
        while(p < end)
        {
                result += *p++;
        }
        return result;
}
```
- \*p++가 배열 인덱스로 접근하는 것보다 이론상으로 빠르다
- 배열은 첫 주소로부터 오프셋을 계산해야 함
- 포인터는 이미 다음 주소에 가있기 때문에 그대로 참조하면 된다
- 요즘 컴파일러는 최적화를 잘 해서 성능은 비슷할 것
	- 그러나 포팅을 생각해서 C에서는 여전히 \*p++을 많이 쓴다.

---
Created: 2024-01-03T17:52:00
Updated: 2024-01-03T17:52:00
Course: COMP2200
tags: 
Reviewed: false
---
- [[#포인터의 비교|포인터의 비교]]
- [[#포인터의 크기|포인터의 크기]]
- [[#포인터와 ../C 기본 문법&빌드 단계/C 배열/C 배열 C 배열|포인터와 C 배열]]
	- [[#포인터와 ../C 기본 문법&빌드 단계/C 배열/C 배열 C 배열#배열 속 각 요소의 위치 계산|배열 속 각 요소의 위치 계산]]
	- [[#포인터와 ../C 기본 문법&빌드 단계/C 배열/C 배열 C 배열#포인터와 배열의 차이|포인터와 배열의 차이]]


## 포인터의 비교
---
- 위에서 NULL과의 비교와 같이 포인터 변수도 비교 가능
	- \==, >, <, != 등등...

## 포인터의 크기
---
- 모든 포인터는 동일한 크기
- 크기는 코드를 컴파일하는 시스템 아키텍쳐에 따라 결정됨
	- 보통 워드 크기와 동일

## 포인터와 [[../../C 기본 문법&빌드 단계/C 배열/C 배열|C 배열]]
---
- 배열을 매개변수로 넘기면?
	- 첫 번째 요소의 메모리 주소가 복사되며
	- 그 크기는 보통 시스템 워드 크기와 동일
- 즉, 포인터와 같다.
```c
#define NULL ((void*)0)

int main(void)
{
        int arr[] = { 0, 1, 2, 3, 4 };
        int* ptr1 = arr;
        int* ptr2 = &arr[0];
        /* int* ptr3 = arr[0]; */ /* 컴파일 에러 */

        return 0;
}
```

### 배열 속 각 요소의 위치 계산
- 배열 속 각 요소 사이의 바이트 간격은 자료형 크기로 일정
- 즉 시작 위치와 자료형 크기만 알면 n번째 요소의 주소 알 수 있음
- 포인터에 정수1를 더하면?
	- 포인터의 위치를 다음 데이터의 위치로 이동
	- 1 바이트를 더하는 것이 아님.
		- 데이터 바이트 크기만큼 증가.
	- 뺄셈, ++, --도 마찬가지.
- 즉 index를 배열 주소를 저장하는 포인터에 더하면 해당 인덱스의 주소가 나옴
- 아래의 세 표현식은 컴파일러에게 똑같은 의미
	- nums\[1]
	- ptr\[1]
	- \*(ptr + 1)
- 포인터 매개변수로 배열을 받는 것도 가능
- 정말 딱 '한' 바이트만 옮기고 싶으면 char\*로 캐스팅 후 증가시키면 됨

### 포인터와 배열의 차이
1. sizeof 연산자
	- 배열: 배열의 총 크기를 반환
	- 포인터: 포인터의 크기를 반환
1. 문자열 초기화
	-  C는 문자열 자료형이 없음
	- 대신 char 배열 사용
		- 문자열이 끝나는 지점을 표시하기 위해 길이 + 널 문자 포함되는 배열 사용
	- 배열을 두 가지 방법으로 초기화 가능.
		- 배열로 초기화할 경우 스택에 저장됨.
			- 스택 프레임이 생성될 때 데이터 섹션에서 복사해옴
			- 이 것은 수정 가능.
		- 포인터로 초기화할 경우 데이터 섹션의 주소가 저장됨
			- 실제 문자열은 스택에 없음.
			- 이 문자열은 수정할 경우 undefined behavior	
1. 대입
	- 포인터 변수는 초기화 후 값 대입 가능
	- 배열에는 불가능
1. 산술 연산
	- 포인터는 산술 연산 가능
	- 배열은 불가능

## 포인터 배열
---
```C
int nums1[3] = {11, 22, 33 };
int nums2[1] = { 90 };
int nums3[4] = { 88, 36, 37 };

int* num_pointers[3];
num_pointers[0] = nums1;
num_pointers[1] = nums2;
num_pointers[2] = nums3;
```
- 행과 열이 있는 2차원 배열과 유사.
- 그러나 모든 행이 같은 길이일 필요는 없음.
- 함수에서 접근하려면 각 내부 배열의 길이를 알려주는 size_t 배열도 필요함.
```C
void print_array(int* const data[], const size_t size, const size_t lengths[])
{
	size_t i;
	size_t j;
	const int* p;

	for(i = 0; i < size; ++i)
	{
		p = data[i];
		printf("nums[%d]:", i);
		for(j = 0; j < lengths[i]; ++j)
		{
			printf(" %d", p[j]);
		}
		printf("\n");
	}
}
```

### 2차원 포인터 배열
```c
void do_magic(int* matrix[])
{
        /* 멋진 코드 */
}

int main(void)
{
        int matrix[5][10] = {
                { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },
                { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },
                { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },
                { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },
                { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },
        };

        do_magic(matrix);
}
```
![[../../../Pasted image 20240117154234.png]]
- 1차원 배열에서는 배열 이름을 포인터로 변환하는 것이 가능했음
- 하지만 2차원 배열에서는 불가
- 2D 배열은 한 덩어리 메모리라 주솟값이 저장된 곳이 없음.
- 올바른 방법

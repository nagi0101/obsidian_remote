---
Created: 2023-12-23T18:24:00
Updated: 2023-12-23T18:24:00
Course: COMP2200
tags: 
Reviewed: false
---

## 여러개의 파일과 C 빌드
---
1. 두 개 이상의 .c 파일을 개별적으로 컴파일하여 오브젝트 파일을 만듦
	1. 이들은 멀티스레딩으로 동시에 진행 가능하기도 함. 어찌 되었건 각자가 독립적으로 컴파일 되는 것이 중요.
2. 오프젝트 파일을 서로 링크하여 실행파일 만듦
	1. 이들은 동시 진행 어려움.

```C
/* monster_repo.h */ 
void add_monster(void);

/* monster_repo.c */
\#include "monster_repo.h"

int g_mob_count = 0;

void add_monster(void)
{
	++g_mob_count;
}

/* main.c */
\#include <stdio.h>
\#include "monster_repo.h"

int main(void)
{
	add_monster();
	printf("# monsters: %d\n", g_mob_count);

	return 0;
}
```
![[Pasted image 20231223190654.png]]
- C 파일의 컴파일은 독립적으로 진행되기 때문에 main.c는 g_mob_count의 존재를 모름.
- 그렇다고 main에서 g_mob_count를 또 추가하면 컴파일은 되지만 링커가 오류를 밷음.
	- ![[Pasted image 20231223191036.png]]
	- 같은 이름의 전역 변수가 두 개면 안 됨. 링커가 구분을 못 함.
- 따라서 함수 전방선언과 같이 구멍을 비워두라는 표시가 필요.

## extern 키워드
---
- external의 약자. 외부의 것을 가져다 쓸테니 구멍으로 비워두라는 키워드임.
```C
/* monster_repo.h */ 
extern int g_mob_count;
void add_monster(void);

```
- 혹은 main함수에 작성하기도 함. 공개하기 싫은 전역 변수는 헤더에 포함시키지 않기도 함.
- 접근 제어와는 느낌이 다른 것이 이쪽은 사용하는 쪽에서 그냥 가져다 쓰겠다고 선언하는 것.

### 사용법
- 그럼 extern을 사용하려면 .c를 일일이 열어서 전역 변수를 찾아야 하는가?
	- 그래도 되지만 라이브러리를 가져다 쓸 경우 .c를 볼 수 없음. 이 경우 제작자가 extern을 헤더에 포함시켜줌. 그게 아닐 경우 바이너리 뜯지 않는 이상 못 쓴다고 생각하면 됨.
- 여전히 c 안에 직접 extern을 넣는 경우도 많음
	- 헤더에 두면 누구라도 쓸 수 있게 해주는 것
	- c에 넣는 것은 파일 내에서만 쓰려고 하는 것
- 